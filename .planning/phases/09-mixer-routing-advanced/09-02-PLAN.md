---
phase: 09-mixer-routing-advanced
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/mixer.ts
  - src/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "Tool get_mixer_routing returns full routing table from FL Studio"
    - "Tool get_track_sends returns sends for a track (by index or name)"
    - "Tool create_send creates a route with optional initial level (supports %, dB, or normalized)"
    - "Tool remove_send removes a route between tracks"
    - "Tool set_send_level sets level for existing route (supports %, dB, or normalized)"
    - "Tool get_mixer_eq returns all 3 EQ bands with dB and Hz values"
    - "Tool set_mixer_eq_band sets EQ parameters (gain, frequency, bandwidth)"
    - "Tool discover_mixer_effect discovers plugin in mixer track slot"
    - "Tool get_mixer_effect_param gets effect parameter by name"
    - "Tool set_mixer_effect_param sets effect parameter by name"
  artifacts:
    - path: "src/tools/mixer.ts"
      provides: "Routing, EQ, and effect slot MCP tools"
      contains: "get_mixer_routing"
      contains: "get_mixer_eq"
      contains: "discover_mixer_effect"
  key_links:
    - from: "src/tools/mixer.ts"
      to: "mixer.get_routing"
      via: "connection.executeCommand"
      pattern: "executeCommand.*mixer\\.get_routing"
    - from: "src/tools/mixer.ts"
      to: "plugins.discover"
      via: "connection.executeCommand with slotIndex"
      pattern: "executeCommand.*plugins\\.discover"
    - from: "src/tools/mixer.ts effect slot tools"
      to: "paramCache.resolveParam"
      via: "track parameter maps to channelIndex in mixer context"
      pattern: "paramCache\\.resolveParam"
---

<objective>
Add MCP tools for mixer routing, EQ control, and effect slot access to the existing mixer.ts.

Purpose: Exposes mixer routing and EQ functionality to Claude via MCP tools, plus convenience wrappers for accessing effects in mixer slots.

Output: Extended mixer.ts with 10 new tools (5 routing, 2 EQ, 3 effect slot convenience wrappers).

**User Decision Compliance:**
- Track references: Accept BOTH name (string) and index (number) per user decision
- Level format: Accept normalized (0-1), percentage (0-100), OR decibels (-inf to +6dB) per user decision
- Pre/post fader: NOT supported - FL Studio API limitation (documented in CONTEXT.md)
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mixer-routing-advanced/09-RESEARCH.md
@src/tools/mixer.ts
@src/tools/plugins.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add routing tools with level format conversion (get_mixer_routing, get_track_sends, create_send, remove_send, set_send_level)</name>
  <files>src/tools/mixer.ts</files>
  <action>
Add 5 routing tools to mixer.ts following the established patterns (Zod schema, try/catch, JSON.stringify result).

**First, add level conversion helper at top of file (after rgbHexToBgr):**

```typescript
/**
 * Convert level input to FL Studio normalized value (0.0-1.0).
 * FL Studio uses 0.8 = unity gain (0dB), not 1.0.
 *
 * Accepts:
 * - Normalized: 0.0-1.0 directly (when levelPercent and levelDb are undefined)
 * - Percentage: 0-100 maps to 0.0-1.0 (100% = 1.0, which is +5.6dB)
 * - Decibels: dB value where 0dB = 0.8 normalized
 *
 * @returns Normalized level 0.0-1.0
 */
function normalizeSendLevel(
  level?: number,
  levelPercent?: number,
  levelDb?: number
): number {
  if (levelDb !== undefined) {
    // dB conversion: 0dB = 0.8, formula approximates FL Studio's curve
    // Clamp to reasonable range (-inf to +6dB)
    const clampedDb = Math.max(-60, Math.min(6, levelDb));
    if (clampedDb <= -60) return 0;
    // FL Studio: 0.8 = 0dB, scale is roughly 10^(dB/50) * 0.8
    return Math.min(1.0, 0.8 * Math.pow(10, clampedDb / 50));
  }
  if (levelPercent !== undefined) {
    // Percentage: 0-100 maps to 0.0-1.0
    return Math.max(0, Math.min(1, levelPercent / 100));
  }
  if (level !== undefined) {
    // Already normalized
    return Math.max(0, Math.min(1, level));
  }
  // Default to unity gain
  return 0.8;
}
```

**Then add the 5 routing tools:**

1. `get_mixer_routing` - Get full routing table
   - Schema: no required params
   - Calls `mixer.get_routing`
   - Returns JSON with all active routes

2. `get_track_sends` - Get sends for a specific track
   - Schema: `track` (z.union([z.number(), z.string()])) - accepts BOTH index and name
   - Description: "Mixer track (index like 0=Master, 1+=inserts, OR track name for lookup)"
   - If string, pass as `name` param; if number, pass as `index` param
   - Calls `mixer.get_track_sends` with `{index: track}` or `{name: track}` based on type
   - Returns sends for that track

3. `create_send` - Create a send route
   - Schema:
     - `source` (z.union([z.number(), z.string()]), required) - source mixer track
     - `destination` (z.union([z.number(), z.string()]), required) - destination mixer track
     - `level` (z.number().min(0).max(1), optional) - normalized level (0-1)
     - `levelPercent` (z.number().min(0).max(100), optional) - percentage (0-100)
     - `levelDb` (z.number().min(-60).max(6), optional) - decibels (-60 to +6dB, 0dB = unity)
   - Description: "Create a send route. Level accepts: normalized (0-1 where 0.8=0dB), percentage (0-100), or decibels (-60 to +6dB). If no level specified, defaults to unity (0dB)."
   - Use `normalizeSendLevel()` to convert input to normalized value
   - Calls `mixer.set_route` with source/destination resolved (pass as-is, handler resolves)
   - If level provided AND not 0.8, also calls `mixer.set_route_level` to set level
   - Returns combined result

4. `remove_send` - Remove a send route
   - Schema:
     - `source` (z.union([z.number(), z.string()]), required)
     - `destination` (z.union([z.number(), z.string()]), required)
   - Calls `mixer.set_route` with `{source, destination, enabled: false}`
   - Returns result

5. `set_send_level` - Set send level for existing route
   - Schema:
     - `source` (z.union([z.number(), z.string()]), required)
     - `destination` (z.union([z.number(), z.string()]), required)
     - `level` (z.number().min(0).max(1), optional) - normalized (0-1)
     - `levelPercent` (z.number().min(0).max(100), optional) - percentage (0-100)
     - `levelDb` (z.number().min(-60).max(6), optional) - decibels (-60 to +6dB)
   - Description: "Set send level. Accepts: normalized (0-1 where 0.8=0dB), percentage (0-100), or decibels. At least one level format required."
   - Validate at least one level format is provided
   - Use `normalizeSendLevel()` to convert
   - Calls `mixer.set_route_level` with normalized value
   - Returns result

Tool descriptions should mention:
- Track accepts BOTH index (0=Master, 1+=inserts) and name (string lookup)
- Level 0.8 = unity gain (0dB) in normalized format
- Level can be specified as normalized, percentage, or dB

Add these after the existing color tool (end of registerMixerTools function).
  </action>
  <verify>Read mixer.ts and confirm all 5 routing tool registrations exist with:
- z.union([z.number(), z.string()]) for track parameters
- normalizeSendLevel helper function
- Multiple level format options (level, levelPercent, levelDb)
- Proper descriptions mentioning name/index and level formats</verify>
  <done>Five routing tools implemented with name+index support, multiple level formats (normalized/percent/dB), and proper Zod schemas.</done>
</task>

<task type="auto">
  <name>Task 2: Add EQ tools (get_mixer_eq, set_mixer_eq_band)</name>
  <files>src/tools/mixer.ts</files>
  <action>
Add 2 EQ tools to mixer.ts:

1. `get_mixer_eq` - Get track EQ settings
   - Schema: `track` (z.union([z.number(), z.string()]), required) - mixer track (index or name)
   - Description: "Get EQ settings for a mixer track (by index or name)"
   - Pass track to handler; if number use `index`, if string use `name`
   - Calls `mixer.get_eq` with `{index: track}` or `{name: track}`
   - Returns all 3 bands with gain (normalized + dB), frequency (normalized + Hz), bandwidth

2. `set_mixer_eq_band` - Set EQ band parameters
   - Schema:
     - `track` (z.union([z.number(), z.string()]), required) - mixer track (index or name)
     - `band` (z.number().int().min(0).max(2), required) - band index (0=Low, 1=Mid, 2=High)
     - `gain` (z.number().min(0).max(1), optional) - normalized gain
     - `frequency` (z.number().min(0).max(1), optional) - normalized frequency
     - `bandwidth` (z.number().min(0).max(1), optional) - normalized bandwidth
   - At least one of gain/frequency/bandwidth should be provided
   - Pass track to handler with appropriate key
   - Calls `mixer.set_eq_band` with `{index/name: track, band, gain?, frequency?, bandwidth?}`
   - Returns updated band settings

Tool descriptions:
- Mention track accepts BOTH index and name
- Mention band names: 0=Low, 1=Mid, 2=High
- Values are normalized 0-1, response includes dB and Hz equivalents
- Default EQ has no effect (0.5 gain = 0dB, frequencies at neutral points)
  </action>
  <verify>Read mixer.ts and confirm both EQ tool registrations exist with:
- z.union([z.number(), z.string()]) for track parameter
- Band descriptions and optional parameter handling
- Descriptions mentioning name/index support</verify>
  <done>Two EQ tools implemented with name+index support, band index validation, and optional parameter support.</done>
</task>

<task type="auto">
  <name>Task 3: Add effect slot convenience tools (discover_mixer_effect, get_mixer_effect_param, set_mixer_effect_param)</name>
  <files>src/tools/mixer.ts</files>
  <action>
Add 3 effect slot convenience tools that wrap the existing plugin system. These provide a mixer-focused interface without requiring users to understand the slotIndex convention.

**Key clarification on paramCache integration:**
- In mixer context, `track` (mixer track index) = `channelIndex` in the plugin system
- The paramCache uses `channelIndex` + `slotIndex` as composite key
- When calling paramCache methods, pass `track` as the `channelIndex` parameter
- Plugin discovery via `plugins.discover` works with `{index: track, slotIndex: slot}`

**Add these imports at top of mixer.ts:**
```typescript
import { paramCache } from '../plugins/param-cache.js';
import { shadowState } from '../plugins/shadow-state.js';
```

**Then add the 3 tools:**

1. `discover_mixer_effect` - Discover a plugin in a mixer track's effect slot
   - Schema:
     - `track` (z.number().int().min(0), required) - mixer track index (0=Master, 1+=inserts)
     - `slot` (z.number().int().min(0).max(9), required) - effect slot index (0-9)
   - Description: "Discover a plugin in a mixer track's effect slot. Returns plugin name and parameter list."
   - Calls `plugins.discover` with `{index: track, slotIndex: slot}`
   - On success, store in paramCache: `paramCache.store(track, slot, pluginName, parameters)`
   - Returns plugin name and parameter count

2. `get_mixer_effect_param` - Get an effect parameter by name
   - Schema:
     - `track` (z.number().int().min(0), required) - mixer track index
     - `slot` (z.number().int().min(0).max(9), required) - effect slot index
     - `name` (z.string(), required) - parameter name (fuzzy matched)
   - Description: "Get a parameter value from a mixer effect slot plugin by name. Requires prior discovery."
   - First check paramCache: `paramCache.get(track, slot)` - track IS the channelIndex for mixer slots
   - If not cached, return error instructing to call discover_mixer_effect first
   - Resolve name: `const resolved = paramCache.resolveParam(track, slot, name)`
   - If resolution fails, return error with available parameter names
   - Call `plugins.get_param` with `{index: track, slotIndex: slot, paramIndex: resolved.index}`
   - Return value with parameter name and index

3. `set_mixer_effect_param` - Set an effect parameter by name
   - Schema:
     - `track` (z.number().int().min(0), required) - mixer track index
     - `slot` (z.number().int().min(0).max(9), required) - effect slot index
     - `name` (z.string(), required) - parameter name (fuzzy matched)
     - `value` (z.number().min(0).max(1), required) - normalized value (0-1)
   - Description: "Set a parameter value on a mixer effect slot plugin by name. Requires prior discovery."
   - Same resolution flow as get
   - Call `plugins.set_param` with `{index: track, slotIndex: slot, paramIndex: resolved.index, value}`
   - Update shadowState: `shadowState.set(track, slot, resolved.index, value)`
   - Return result with parameter name and new value

**Note:** For mixer slots, `track` IS `channelIndex` in the plugin system context. This is because FL Studio uses the mixer track index as the channel index when accessing plugins in mixer effect slots.
  </action>
  <verify>Read mixer.ts and confirm all 3 effect slot tools exist with:
- Proper imports of paramCache and shadowState
- `track` parameter used as `channelIndex` when calling paramCache methods
- Parameter name resolution via `paramCache.resolveParam(track, slot, name)`
- shadowState updates on set operations
- Clear error messages when plugin not discovered</verify>
  <done>Three effect slot convenience tools implemented, correctly mapping track to channelIndex for paramCache integration, with proper name resolution and shadowState updates.</done>
</task>

<task type="auto">
  <name>Task 4: Build and verify TypeScript compiles</name>
  <files>src/tools/mixer.ts, src/tools/index.ts</files>
  <action>
1. Run `npm run build` from the project root
2. Verify no TypeScript errors
3. Check that the build output includes the updated mixer tools

If there are import errors for paramCache or shadowState:
- Verify the import paths are correct: `../plugins/param-cache.js` and `../plugins/shadow-state.js`
- Check that the exports exist in those modules

If there are type errors:
- Add proper type annotations for the plugin discover/get/set response shapes
- Use `as unknown as Type` pattern if needed (following existing plugins.ts patterns)
  </action>
  <verify>
Run: `npm run build` - should complete with no errors
Run: `ls -la dist/tools/mixer.js` - should exist and be recently modified
  </verify>
  <done>TypeScript compiles successfully with all new tools included in build output.</done>
</task>

<task type="auto">
  <name>Task 5: Manual verification of effect slot paramCache integration</name>
  <files>N/A - verification only</files>
  <action>
This task verifies that the effect slot tools correctly integrate with the plugin infrastructure.

**Test flow (document in SUMMARY.md):**

1. **Discover plugin:** Call `discover_mixer_effect` with a mixer track that has a plugin loaded (e.g., track 1, slot 0 with a reverb)
   - Verify response includes plugin name
   - Verify paramCache is populated (subsequent calls should use cache)

2. **Resolve parameter name:** Call `get_mixer_effect_param` with the track/slot and a parameter name
   - Verify fuzzy matching works (e.g., "mix" matches "Dry/Wet Mix")
   - Verify error message if parameter not found lists available names

3. **Set parameter value:** Call `set_mixer_effect_param` with track/slot, name, and value
   - Verify the value changes in FL Studio
   - Verify shadowState is updated (observable via subsequent get returning cached value before FL Studio responds)

4. **Verify track=channelIndex mapping:** Confirm that using mixer track index (e.g., 5) works correctly with paramCache methods that expect channelIndex

**If manual testing reveals issues:**
- Document the issue in SUMMARY.md under "Issues Found"
- These would become gap closure items for a future plan
  </action>
  <verify>
Document test results in SUMMARY.md with:
- Which track/slot/plugin was tested
- Whether paramCache correctly stored and retrieved parameters
- Whether shadowState updates worked
- Any issues found
  </verify>
  <done>Manual verification completed and documented. Effect slot tools correctly integrate with paramCache using track as channelIndex.</done>
</task>

</tasks>

<verification>
After all tasks:
1. `grep -c "server.tool" src/tools/mixer.ts` should return 16 (6 original + 5 routing + 2 EQ + 3 effect slot)
2. `npm run build` succeeds with no errors
3. All tools have proper Zod schemas with z.union for track parameters where applicable
4. normalizeSendLevel helper exists and handles all three input formats
5. Effect slot tools properly integrate with paramCache/shadowState
6. Manual test of effect slot tools documented
</verification>

<success_criteria>
- mixer.ts has 16 registered tools (6 Phase 8 + 10 Phase 9)
- Routing tools: get_mixer_routing, get_track_sends, create_send, remove_send, set_send_level
- EQ tools: get_mixer_eq, set_mixer_eq_band
- Effect slot tools: discover_mixer_effect, get_mixer_effect_param, set_mixer_effect_param
- Track parameters accept BOTH name (string) and index (number) where applicable
- Level parameters accept normalized, percentage, OR decibels
- TypeScript build succeeds
- Effect slot tools reuse existing plugin infrastructure with correct track=channelIndex mapping
- Manual verification documents paramCache integration working correctly
</success_criteria>

<output>
After completion, create `.planning/phases/09-mixer-routing-advanced/09-02-SUMMARY.md`
</output>
