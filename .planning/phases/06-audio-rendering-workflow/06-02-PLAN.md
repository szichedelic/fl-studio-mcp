---
phase: 06-audio-rendering-workflow
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/tools/render.ts
  - src/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "User can call render_pattern and receive step-by-step FL Studio export instructions with a suggested filename and output path"
    - "System starts watching for the rendered WAV file automatically when render_pattern is called"
    - "If the WAV file already exists at the target path, it is registered immediately without requiring a new render"
    - "User can call list_renders to see all WAV files detected this session"
    - "User can call check_render to check if a specific render has been detected yet"
    - "Rendered files are tracked in the registry and available for Phase 7 consumption"
  artifacts:
    - path: "src/tools/render.ts"
      provides: "MCP tools: render_pattern, list_renders, check_render"
      exports: ["registerRenderTools"]
    - path: "src/tools/index.ts"
      provides: "Updated tool registration including render tools"
      contains: "registerRenderTools"
  key_links:
    - from: "src/tools/render.ts"
      to: "src/audio/render-watcher.ts"
      via: "imports renderWatcher, calls startWatching/checkExisting"
      pattern: "renderWatcher\\.(startWatching|checkExisting)"
    - from: "src/tools/render.ts"
      to: "src/audio/render-registry.ts"
      via: "imports renderRegistry, calls getAll/getLatest/getByFilename"
      pattern: "renderRegistry\\.(getAll|getLatest|getByFilename)"
    - from: "src/tools/render.ts"
      to: "src/bridge/connection.ts"
      via: "calls connection.executeCommand for FL Studio state"
      pattern: "connection\\.executeCommand"
    - from: "src/tools/index.ts"
      to: "src/tools/render.ts"
      via: "imports and calls registerRenderTools"
      pattern: "registerRenderTools"
---

<objective>
Create the MCP render tools (render_pattern, list_renders, check_render) and wire them into the tool registry.

Purpose: These tools are the user-facing interface for Phase 6. render_pattern generates guided instructions and starts the file watcher; list_renders and check_render let the user query detected renders. This completes the audio rendering workflow.
Output: `src/tools/render.ts` with 3 MCP tools, updated `src/tools/index.ts` with render tool registration.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-audio-rendering-workflow/06-RESEARCH.md
@.planning/phases/06-audio-rendering-workflow/06-01-SUMMARY.md
@src/tools/index.ts
@src/tools/serum.ts
@src/bridge/connection.ts
@src/audio/types.ts
@src/audio/render-registry.ts
@src/audio/render-watcher.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP render tools</name>
  <files>src/tools/render.ts</files>
  <action>
    Create `src/tools/render.ts` following the same pattern as serum.ts and other tool files.

    Structure:
    ```
    import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
    import type { ConnectionManager } from '../bridge/connection.js';
    import { z } from 'zod';
    import { join } from 'node:path';
    import { homedir } from 'node:os';
    import { existsSync } from 'node:fs';
    import { mkdir } from 'node:fs/promises';
    import { renderWatcher } from '../audio/render-watcher.js';
    import { renderRegistry } from '../audio/render-registry.js';
    import type { RenderInfo } from '../audio/types.js';
    ```

    **Helper: getDefaultRenderDir()**
    - Returns `join(homedir(), 'Documents', 'FL Studio MCP', 'Renders')`
    - This is the MCP-managed directory the user is instructed to save to

    **Helper: sanitizeFilename(name: string): string**
    - Replace `[<>:"/\\|?*]` with empty string (illegal Windows filename chars)
    - Replace whitespace runs with `_`
    - Collapse multiple underscores to single
    - Trim leading/trailing underscores
    - Limit to 100 characters
    - Fallback to `'render'` if result is empty

    **Export: registerRenderTools(server: McpServer, connection: ConnectionManager): void**

    **Tool 1: render_pattern**
    - Name: `'render_pattern'`
    - Description: `'Get step-by-step instructions to render the current pattern as a WAV file. Automatically starts watching for the rendered file.'`
    - Params:
      - `filename`: `z.string().optional().describe('Custom filename without extension. Omit for auto-generated name based on current pattern.')`
      - `outputDir`: `z.string().optional().describe('Output directory. Defaults to ~/Documents/FL Studio MCP/Renders/')`
    - Handler:
      1. Read current FL Studio state: `connection.executeCommand('state.patterns', {})`
         - Extract current pattern name from result. Fallback to `'Pattern'` if unavailable.
         - Wrap in try/catch -- if FL Studio is not connected, still generate instructions with generic name.
      2. Generate filename: use `filename` param if provided, otherwise `sanitizeFilename(patternName + '_render')`
      3. Determine output dir: use `outputDir` param if provided, otherwise `getDefaultRenderDir()`
      4. Ensure output directory exists: `await mkdir(renderDir, { recursive: true })`
      5. Build full filename with `.wav` extension
      6. Check if file already exists via `renderWatcher.checkExisting(fullFilename, renderDir)`
         - If exists, return message: file already exists, registered for sample manipulation
      7. Start watcher: `renderWatcher.startWatching(renderDir)`
      8. Return step-by-step instructions as text content:
         ```
         Render "{patternName}" to WAV:

         1. Make sure you are in Pattern mode (not Song mode)
            - Check the Pat/Song toggle in the transport bar
         2. Press Ctrl+R (or File > Export > Wave File)
         3. Navigate to: {renderDir}
         4. Set filename to: {fullFilename}
         5. Recommended settings:
            - Format: WAV
            - Bit depth: 32-Bit float
            - Mode: Pattern
         6. Click "Start" to begin rendering

         Watching for: {fullFilename}
         I will automatically detect when the render completes.
         ```
      9. On error, return `{ content: [{ type: 'text', text: error message }], isError: true }`

    **Tool 2: list_renders**
    - Name: `'list_renders'`
    - Description: `'List all rendered WAV files detected this session. These files are available for sample manipulation.'`
    - Params: none (empty object `{}`)
    - Handler:
      1. Get all renders from `renderRegistry.getAll()`
      2. If empty, return "No renders detected yet. Use render_pattern to start a render workflow."
      3. Otherwise format as list:
         ```
         Rendered files ({count}):

           {filename}
             Path: {path}
             Detected: {time}
             Source: {patternName} (if known)
         ```
      4. Include a final line: "These files are ready for sample manipulation."

    **Tool 3: check_render**
    - Name: `'check_render'`
    - Description: `'Check if a specific rendered WAV file has been detected.'`
    - Params:
      - `filename`: `z.string().describe('Filename to check (with or without .wav extension)')`
    - Handler:
      1. Normalize filename: ensure it ends with `.wav`
      2. Check `renderRegistry.getByFilename(filename)`
      3. If found: return "Render detected: {filename}" with path, timestamp, pattern info
      4. If not found:
         - Check if watcher is active via `renderWatcher.isWatching()`
         - If watching: return "Not detected yet. Still watching {directory}... Make sure you saved to the correct location."
         - If not watching: return "Not detected. No active watcher. Call render_pattern first to start watching."
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
  </verify>
  <done>
    - src/tools/render.ts exports registerRenderTools function
    - render_pattern tool reads FL Studio state, generates smart filename, creates output dir, starts watcher, returns step-by-step instructions
    - list_renders tool returns all tracked renders from registry
    - check_render tool checks if a specific render has been detected
    - All tools handle errors gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Register render tools and verify full build</name>
  <files>src/tools/index.ts</files>
  <action>
    1. Update `src/tools/index.ts`:
       - Add import: `import { registerRenderTools } from './render.js';`
       - Add call in registerTools function: `registerRenderTools(server, connection);`
       - Update the console.error log to include 'render' in the tools list

    2. Run full build: `npm run build`
    3. Verify dist/ output includes the new files
  </action>
  <verify>
    - `npm run build` succeeds with zero errors
    - `ls dist/audio/` shows types.js, render-registry.js, render-watcher.js
    - `ls dist/tools/render.js` exists
    - The string 'render' appears in dist/tools/index.js (grep for it)
  </verify>
  <done>
    - src/tools/index.ts imports and registers render tools alongside existing tools
    - Full project builds cleanly
    - All new files appear in dist/ output
    - Render tools are registered with the MCP server
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds -- all source compiles to dist/
2. dist/tools/render.js exists and contains render_pattern, list_renders, check_render tool registrations
3. dist/tools/index.js references registerRenderTools
4. dist/audio/ contains types.js, render-registry.js, render-watcher.js
5. No TypeScript errors in the full project
</verification>

<success_criteria>
- render_pattern MCP tool generates context-aware step-by-step render instructions with smart filenames
- render_pattern starts chokidar watcher automatically for the output directory
- list_renders MCP tool returns all session-tracked renders from the registry
- check_render MCP tool confirms whether a specific render has been detected
- All 3 tools registered in the MCP server via tools/index.ts
- Full project builds cleanly with `npm run build`
- Phase 6 requirements REN-01 (guided workflow) and REN-02 (automatic detection + tracking) are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/06-audio-rendering-workflow/06-02-SUMMARY.md`
</output>
