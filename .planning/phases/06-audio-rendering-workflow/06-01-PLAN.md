---
phase: 06-audio-rendering-workflow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/audio/types.ts
  - src/audio/render-registry.ts
  - src/audio/render-watcher.ts
autonomous: true

must_haves:
  truths:
    - "RenderRegistry can store, retrieve, and list render metadata"
    - "RenderWatcher detects new WAV files using chokidar with awaitWriteFinish"
    - "Watcher ignores non-WAV files and pre-existing files"
    - "Watcher resolves pending render promises when expected files appear"
  artifacts:
    - path: "src/audio/types.ts"
      provides: "RenderInfo interface and WatcherConfig type"
      contains: "RenderInfo"
    - path: "src/audio/render-registry.ts"
      provides: "In-memory render tracking singleton"
      exports: ["RenderRegistry", "renderRegistry"]
    - path: "src/audio/render-watcher.ts"
      provides: "Chokidar-based WAV file watcher"
      exports: ["RenderWatcher", "renderWatcher"]
  key_links:
    - from: "src/audio/render-watcher.ts"
      to: "src/audio/render-registry.ts"
      via: "imports renderRegistry, calls register() on WAV detection"
      pattern: "renderRegistry\\.register"
    - from: "src/audio/render-watcher.ts"
      to: "chokidar"
      via: "chokidar.watch with awaitWriteFinish"
      pattern: "chokidar\\.watch"
---

<objective>
Install chokidar and create the audio rendering infrastructure: types, in-memory render registry, and file watcher service.

Purpose: Phase 6 needs a foundation layer that detects rendered WAV files and tracks them. This plan builds the core audio/ module that the MCP tools (Plan 02) will consume.
Output: `src/audio/` directory with types, registry, and watcher -- all importable and ready for tool wiring.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-audio-rendering-workflow/06-RESEARCH.md
@src/tools/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install chokidar and create audio types</name>
  <files>package.json, src/audio/types.ts</files>
  <action>
    1. Install chokidar v4: `npm install chokidar@^4.0.3`

    2. Create `src/audio/types.ts` with:
       - `RenderInfo` interface:
         - `path: string` (absolute path to WAV file)
         - `filename: string` (just the filename)
         - `timestamp: number` (Date.now() when detected)
         - `patternName?: string` (source pattern name if known)
         - `channelName?: string` (source channel name if known)
       - `WatcherConfig` interface:
         - `directory: string` (directory to watch)
         - `stabilityThreshold?: number` (default 2000ms)
         - `pollInterval?: number` (default 500ms)
         - `timeoutMs?: number` (default 300000 = 5 minutes)

    Keep types minimal. No classes, just interfaces/types.
  </action>
  <verify>
    - `npm ls chokidar` shows chokidar@4.x installed
    - `npx tsc --noEmit src/audio/types.ts` compiles without errors
  </verify>
  <done>chokidar is in package.json dependencies, types.ts exports RenderInfo and WatcherConfig interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Create render registry and WAV file watcher</name>
  <files>src/audio/render-registry.ts, src/audio/render-watcher.ts</files>
  <action>
    1. Create `src/audio/render-registry.ts`:
       - `RenderRegistry` class with:
         - `private renders: RenderInfo[]` array
         - `register(info: RenderInfo): void` -- pushes to array, logs via console.error
         - `getAll(): RenderInfo[]` -- returns copy of array
         - `getLatest(): RenderInfo | undefined` -- last element
         - `getByFilename(name: string): RenderInfo | undefined` -- case-insensitive match
         - `count(): number`
         - `clear(): void`
       - Export singleton: `export const renderRegistry = new RenderRegistry();`
       - Import `RenderInfo` from `./types.js`

    2. Create `src/audio/render-watcher.ts`:
       - Import chokidar (default import: `import chokidar from 'chokidar';`)
       - Import `basename` from `node:path`, `existsSync` from `node:fs`, `mkdir` from `node:fs/promises`
       - Import `renderRegistry` from `./render-registry.js`
       - Import `RenderInfo` from `./types.js`

       - `RenderWatcher` class:
         - `private watcher: ReturnType<typeof chokidar.watch> | null = null`
         - `private watchedDir: string | null = null`

         - `startWatching(directory: string): void`
           - If already watching this directory, return early
           - If watching a different directory, close existing watcher first
           - Create directory if it doesn't exist using `mkdirSync` (from `node:fs`)
           - `this.watcher = chokidar.watch(directory, { ... })`
           - Options: `persistent: true`, `ignoreInitial: true`, `depth: 0`
           - `awaitWriteFinish: { stabilityThreshold: 2000, pollInterval: 500 }`
           - `ignored` filter: ignore files that are not `.wav` (check `path.toLowerCase().endsWith('.wav')`)
             - Note: chokidar v4 `ignored` takes `(path: string, stats?: fs.Stats)`. For files, check extension. For directories, don't ignore (allow traversal).
           - On `'add'` event:
             - Log via `console.error(`[render-watcher] WAV detected: ${basename(filePath)}`)`
             - Build `RenderInfo` with path, filename (basename), timestamp (Date.now())
             - Call `renderRegistry.register(info)`

         - `checkExisting(filename: string, directory: string): string | null`
           - Check if `join(directory, filename)` already exists
           - If so, register it immediately and return the full path
           - Otherwise return null

         - `isWatching(): boolean` -- returns whether watcher is active

         - `getWatchedDirectory(): string | null`

         - `async stop(): Promise<void>` -- close watcher, set to null

       - Export singleton: `export const renderWatcher = new RenderWatcher();`

       IMPORTANT: Do NOT make watchFor return a Promise that blocks. The watcher is fire-and-forget -- it detects files and registers them. The MCP tools will check the registry separately.

       Use `mkdirSync` (not async) in startWatching to keep it synchronous. Import from `node:fs`.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles the full project without errors
    - `npm run build` succeeds
  </verify>
  <done>
    - render-registry.ts exports RenderRegistry class and renderRegistry singleton with register/getAll/getLatest/getByFilename/count/clear methods
    - render-watcher.ts exports RenderWatcher class and renderWatcher singleton with startWatching/checkExisting/isWatching/stop methods
    - Watcher uses chokidar with awaitWriteFinish, ignoreInitial: true, and .wav filter
    - Watcher auto-registers detected WAV files in the registry
    - Full project builds cleanly with `npm run build`
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds -- all new files compile with the existing project
2. `npm ls chokidar` shows chokidar@4.x
3. `ls src/audio/` shows types.ts, render-registry.ts, render-watcher.ts
</verification>

<success_criteria>
- chokidar ^4.0.3 installed in dependencies
- src/audio/ directory exists with types.ts, render-registry.ts, render-watcher.ts
- All three files compile cleanly with the existing TypeScript project
- RenderWatcher uses chokidar with awaitWriteFinish for reliable WAV detection
- RenderRegistry provides in-memory render tracking with register/query methods
</success_criteria>

<output>
After completion, create `.planning/phases/06-audio-rendering-workflow/06-01-SUMMARY.md`
</output>
