---
phase: 07-sample-manipulation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/tools/sample.ts
  - src/tools/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can pitch-shift a sample by semitones and get a new WAV file"
    - "User can reverse a sample and get a new WAV file"
    - "User can time-stretch a sample by a speed factor and get a new WAV file"
    - "User can query a WAV file's sample rate, channels, duration, and precision"
    - "MCP server logs SoX availability status at startup"
    - "Tools accept render registry filenames or absolute paths as input"
  artifacts:
    - path: "src/tools/sample.ts"
      provides: "MCP tool registrations for sample_pitch, sample_reverse, sample_timestretch, sample_info"
      exports: ["registerSampleTools"]
    - path: "src/tools/index.ts"
      provides: "Updated tool registration including sample tools"
      contains: "registerSampleTools"
    - path: "src/index.ts"
      provides: "SoX availability check at startup"
      contains: "soxRunner"
  key_links:
    - from: "src/tools/sample.ts"
      to: "src/audio/sox-runner.ts"
      via: "soxRunner singleton for all SoX operations"
      pattern: "soxRunner\\.(pitch|reverse|tempo|info)"
    - from: "src/tools/sample.ts"
      to: "src/audio/sox-runner.ts"
      via: "resolveInputFile for input path resolution"
      pattern: "resolveInputFile"
    - from: "src/tools/index.ts"
      to: "src/tools/sample.ts"
      via: "import and call registerSampleTools"
      pattern: "registerSampleTools"
    - from: "src/index.ts"
      to: "src/audio/sox-runner.ts"
      via: "startup SoX verification"
      pattern: "soxRunner\\.verify"
---

<objective>
Create the four basic MCP sample tools (pitch, reverse, timestretch, info), register them with the server, and add SoX availability checking at startup.

Purpose: These tools deliver SAM-01 (pitch shift), SAM-02 (reverse), SAM-03 (time stretch) and a supporting info tool. After this plan, users can manipulate individual audio samples via natural language.

Output: `src/tools/sample.ts` with 4 registered tools, updated `src/tools/index.ts` and `src/index.ts`.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-sample-manipulation/07-RESEARCH.md
@.planning/phases/07-sample-manipulation/07-01-SUMMARY.md
@src/tools/render.ts
@src/tools/index.ts
@src/index.ts
@src/audio/sox-runner.ts
@src/audio/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sample tools module with 4 MCP tools</name>
  <files>src/tools/sample.ts</files>
  <action>
Create `src/tools/sample.ts` following the exact pattern of `src/tools/render.ts` (same imports style, same function signature, same error handling pattern).

**Exports:** `registerSampleTools(server: McpServer, connection: ConnectionManager): void`

Note: `connection` parameter is included for consistency with other tool registration functions even though sample tools don't need FL Studio communication. This keeps the interface uniform.

**Imports:**
- `McpServer` from `@modelcontextprotocol/sdk/server/mcp.js`
- `ConnectionManager` from `../bridge/connection.js`
- `z` from `zod`
- `basename`, `dirname`, `join` from `node:path`
- `mkdir` from `node:fs/promises`
- `soxRunner`, `resolveInputFile`, `generateOutputFilename`, `getDefaultSampleDir` from `../audio/sox-runner.js`

**Tool 1: sample_pitch** (SAM-01)
- Name: `'sample_pitch'`
- Description: `'Pitch-shift a WAV sample by semitones without changing duration. Use 12/-12 for octave up/down, 7/-7 for fifth up/down.'`
- Schema:
  - `input`: z.string().describe('Input WAV filename (from list_renders) or absolute path')
  - `semitones`: z.number().describe('Semitones to shift. Positive = up, negative = down. 12 = one octave up, -12 = one octave down.')
  - `outputFilename`: z.string().optional().describe('Custom output filename. Omit for auto-generated name.')
- Handler:
  1. `const inputPath = resolveInputFile(input)`
  2. `const cents = Math.round(semitones * 100)`
  3. Generate output filename: direction is `semitones > 0 ? 'up' : semitones < 0 ? 'down' : 'no_change'`, suffix = `${direction}_${Math.abs(semitones)}st`
  4. `const outName = outputFilename ?? generateOutputFilename(basename(inputPath), 'pitch', suffix)`
  5. `const outputPath = join(getDefaultSampleDir(), outName)`
  6. `await mkdir(dirname(outputPath), { recursive: true })`
  7. `const result = await soxRunner.pitch(inputPath, outputPath, cents)`
  8. Return text content with: what was done, input path, output path, and instruction "To use in FL Studio: drag this file into the Channel Rack or Sampler."
- Error handling: try/catch, return `isError: true` with message on failure.

**Tool 2: sample_reverse** (SAM-02)
- Name: `'sample_reverse'`
- Description: `'Reverse a WAV sample. Creates a new file with the audio played backwards.'`
- Schema:
  - `input`: z.string().describe('Input WAV filename (from list_renders) or absolute path')
  - `outputFilename`: z.string().optional().describe('Custom output filename. Omit for auto-generated name.')
- Handler:
  1. Resolve input, generate output name with operation='reversed' (no suffix)
  2. `await soxRunner.reverse(inputPath, outputPath)`
  3. Return text content with what was done, paths, FL Studio instruction

**Tool 3: sample_timestretch** (SAM-03)
- Name: `'sample_timestretch'`
- Description: `'Time-stretch a WAV sample without changing pitch. Factor < 1 slows down (longer), factor > 1 speeds up (shorter). Uses music-optimized WSOLA algorithm.'`
- Schema:
  - `input`: z.string().describe('Input WAV filename (from list_renders) or absolute path')
  - `factor`: z.number().min(0.1).max(10).describe('Speed factor. 0.5 = half speed (twice as long), 2.0 = double speed (half as long). Range: 0.1 to 10.')
  - `outputFilename`: z.string().optional().describe('Custom output filename. Omit for auto-generated name.')
- Handler:
  1. Resolve input, generate output name with operation='stretched', suffix = `${factor}x`
  2. `await soxRunner.tempo(inputPath, outputPath, factor)`
  3. Return text content with what was done (include the factor and resulting speed description), paths, FL Studio instruction

**Tool 4: sample_info** (supporting tool)
- Name: `'sample_info'`
- Description: `'Get detailed information about a WAV file: duration, sample rate, channels, bit depth.'`
- Schema:
  - `input`: z.string().describe('Input WAV filename (from list_renders) or absolute path')
- Handler:
  1. Resolve input
  2. `const info = await soxRunner.info(inputPath)`
  3. Return formatted text with: filename, path, duration (formatted as mm:ss.ms), sample rate (Hz), channels (with "mono"/"stereo" label), precision, total samples

**Error handling pattern (consistent across all tools):**
```typescript
try {
  // ... tool logic
} catch (error) {
  const msg = error instanceof Error ? error.message : String(error);
  return {
    content: [{ type: 'text' as const, text: `[ToolName] failed: ${msg}` }],
    isError: true,
  };
}
```
  </action>
  <verify>Run `npx tsc --noEmit` -- should compile with no errors.</verify>
  <done>Four MCP tools (sample_pitch, sample_reverse, sample_timestretch, sample_info) are defined in src/tools/sample.ts, each accepting render registry filenames or absolute paths, producing output in ~/Documents/FL Studio MCP/Samples/.</done>
</task>

<task type="auto">
  <name>Task 2: Register sample tools and add SoX startup check</name>
  <files>src/tools/index.ts, src/index.ts</files>
  <action>
**Update src/tools/index.ts:**
1. Add import: `import { registerSampleTools } from './sample.js';`
2. Add call in `registerTools` function: `registerSampleTools(server, connection);` (after `registerRenderTools`)
3. Update the console.error log to include 'sample' in the registered tools list

**Update src/index.ts:**
Add a SoX availability check at startup. After the `await connectToFLStudio()` line and before starting the MCP server, add:

```typescript
// Check SoX availability for sample manipulation tools
try {
  const { soxRunner } = await import('./audio/sox-runner.js');
  const version = await soxRunner.verify();
  console.error(`[fl-studio-mcp] SoX available: ${version}`);
} catch {
  console.error(
    '[fl-studio-mcp] WARNING: SoX is not installed. ' +
    'Sample manipulation tools will not work. ' +
    'Install via: winget install --id ChrisBagwell.SoX -s winget'
  );
}
```

Use dynamic import (`await import(...)`) so that if sox-runner.ts has any module-level issues, it doesn't crash the entire server. The check is informational only -- the server starts regardless. Individual tools will give clear errors if SoX is unavailable.

Note: Place this AFTER `connectToFLStudio()` but BEFORE `server.connect(transport)`. The check is non-blocking and non-fatal (same pattern as MIDI connection).
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- should compile cleanly
2. Run `npm run build` -- should produce dist/ output without errors
  </verify>
  <done>Sample tools are registered with the MCP server. SoX availability is checked and logged at startup. Server starts regardless of SoX availability.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `src/tools/sample.ts` exports `registerSampleTools` and defines 4 tools: sample_pitch, sample_reverse, sample_timestretch, sample_info
3. `src/tools/index.ts` imports and calls `registerSampleTools`
4. `src/index.ts` checks SoX availability at startup with clear logging
5. All tools use `resolveInputFile` for input path resolution (render registry + absolute path + fallback)
6. All tools output to `~/Documents/FL Studio MCP/Samples/` by default
7. All tools return `isError: true` with descriptive messages on failure
</verification>

<success_criteria>
- Four sample tools (pitch, reverse, timestretch, info) are registered and callable via MCP
- SoX availability is checked at server startup with clear warning if missing
- Tools accept both render registry filenames and absolute paths
- TypeScript compiles and builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-sample-manipulation/07-02-SUMMARY.md`
</output>
