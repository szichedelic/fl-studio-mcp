---
phase: 08-mixer-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fl-bridge/handlers/state.py
  - fl-bridge/handlers/mixer.py
  - fl-bridge/handlers/__init__.py
autonomous: true

must_haves:
  truths:
    - "FL Bridge responds to mixer.set_volume with success and readback"
    - "FL Bridge responds to mixer.set_pan with success and readback"
    - "FL Bridge responds to mixer.mute with success and muted state"
    - "FL Bridge responds to mixer.solo with success and soloed state"
    - "FL Bridge responds to mixer.set_name with success and new name"
    - "FL Bridge responds to mixer.set_color with success and color value"
    - "state.mixer response includes color field for each track"
  artifacts:
    - path: "fl-bridge/handlers/mixer.py"
      provides: "Mixer mutation handlers"
      exports: ["mixer.set_volume", "mixer.set_pan", "mixer.mute", "mixer.solo", "mixer.set_name", "mixer.set_color"]
    - path: "fl-bridge/handlers/state.py"
      provides: "Extended mixer state with color"
      contains: "getTrackColor"
    - path: "fl-bridge/handlers/__init__.py"
      provides: "Handler registration"
      contains: "from handlers import mixer"
  key_links:
    - from: "fl-bridge/handlers/mixer.py"
      to: "FL Studio mixer module"
      via: "import mixer"
      pattern: "mixer\\.setTrackVolume|mixer\\.setTrackPan|mixer\\.muteTrack|mixer\\.soloTrack|mixer\\.setTrackName|mixer\\.setTrackColor"
    - from: "fl-bridge/handlers/__init__.py"
      to: "fl-bridge/handlers/mixer.py"
      via: "import on init"
      pattern: "from handlers import mixer"
---

<objective>
Create FL Bridge Python handlers for mixer track mutations and extend state reading to include color.

Purpose: Enable programmatic control of mixer tracks (volume, pan, mute, solo, name, color) from MCP server via the FL Bridge protocol.

Output: Six new command handlers in `mixer.py`, one state extension in `state.py`, handler registration in `__init__.py`.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mixer-core/08-RESEARCH.md

# Existing patterns to follow
@fl-bridge/handlers/plugins.py
@fl-bridge/handlers/state.py
@fl-bridge/handlers/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend state.mixer to include track color</name>
  <files>fl-bridge/handlers/state.py</files>
  <action>
In `handle_get_mixer()`, add `color` field to each track_info dict:

```python
track_info = {
    'index': i,
    'name': mixer.getTrackName(i),
    'volume': mixer.getTrackVolume(i),
    'pan': mixer.getTrackPan(i),
    'muted': mixer.isTrackMuted(i),
    'solo': mixer.isTrackSolo(i),
    'color': mixer.getTrackColor(i)  # ADD THIS LINE
}
```

This is a single line addition. The color is returned in FL Studio's BGR format (0x--BBGGRR).
  </action>
  <verify>
Read the file and confirm `'color': mixer.getTrackColor(i)` is present in the track_info dict.
  </verify>
  <done>
`state.mixer` handler returns color for each mixer track in BGR integer format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create mixer.py with mutation handlers</name>
  <files>fl-bridge/handlers/mixer.py</files>
  <action>
Create new handler module following the pattern from `plugins.py`. Include these handlers:

**1. mixer.set_volume**
- Params: `index` (int, required), `volume` (float, required, 0.0-1.0)
- Validate: index in range, volume in range
- Call: `mixer.setTrackVolume(index, volume, midi.PIM_None)`
- Return: `{success, index, volume: mixer.getTrackVolume(index)}`

**2. mixer.set_pan**
- Params: `index` (int, required), `pan` (float, required, -1.0 to 1.0)
- Validate: index in range, pan in range
- Call: `mixer.setTrackPan(index, pan, midi.PIM_None)`
- Return: `{success, index, pan: mixer.getTrackPan(index)}`

**3. mixer.mute**
- Params: `index` (int, required), `mute` (bool, required)
- Validate: index in range
- Call: `mixer.muteTrack(index, 1 if mute else 0)` (EXPLICIT, not toggle!)
- Return: `{success, index, muted: mixer.isTrackMuted(index)}`

**4. mixer.solo**
- Params: `index` (int, required), `solo` (bool, required)
- Validate: index in range
- Call: `mixer.soloTrack(index, 1 if solo else 0)` (EXPLICIT, not toggle!)
- Return: `{success, index, soloed: mixer.isTrackSolo(index)}`

**5. mixer.set_name**
- Params: `index` (int, required), `name` (str, required)
- Validate: index in range
- Call: `mixer.setTrackName(index, name)`
- Return: `{success, index, name: mixer.getTrackName(index)}`

**6. mixer.set_color**
- Params: `index` (int, required), `color` (int, required, BGR format)
- Validate: index in range
- Call: `mixer.setTrackColor(index, color)`
- Return: `{success, index, color: mixer.getTrackColor(index)}`

**Module structure:**
```python
"""
FL Bridge Mixer Handlers

Handles mixer track mutations: volume, pan, mute, solo, name, color.

REGISTERED HANDLERS:
====================
- mixer.set_volume: Set mixer track volume (0.0-1.0, where 0.8 = 0dB)
- mixer.set_pan: Set mixer track pan (-1.0 to 1.0)
- mixer.mute: Mute/unmute mixer track (explicit, not toggle)
- mixer.solo: Solo/unsolo mixer track (explicit, not toggle)
- mixer.set_name: Set mixer track name
- mixer.set_color: Set mixer track color (BGR format)

AUTHOR: FL Studio MCP Project
"""

from typing import Dict, Any

try:
    import mixer
    import midi
except ImportError:
    mixer = None
    midi = None

from protocol.commands import register_handler

# ... handler functions ...
# ... register_handler calls at end ...
```

**Critical notes:**
- Use `midi.PIM_None` (0) for volume/pan pickup mode (immediate change)
- Use explicit 1/0 for mute/solo, NOT -1 (toggle) - per research pitfall #4
- Validate `index >= 0 and index < mixer.trackCount()`
  </action>
  <verify>
Read the created file and confirm:
1. All 6 handlers are defined
2. Each handler has proper validation
3. mute/solo use explicit 1/0, not -1 toggle
4. register_handler calls at end for all 6 commands
  </verify>
  <done>
`mixer.py` contains 6 validated handlers for all mixer mutations, using explicit mute/solo behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register mixer handlers in __init__.py</name>
  <files>fl-bridge/handlers/__init__.py</files>
  <action>
Add import for the new mixer module to trigger handler registration:

```python
from handlers import mixer
```

Add it after the existing imports (transport, state, patterns, pianoroll). The import triggers the register_handler calls in mixer.py.

Note: `plugins` is NOT imported in __init__.py currently - check if it should be. If plugins handlers work, they may be imported elsewhere. Only add mixer import.
  </action>
  <verify>
Read the file and confirm `from handlers import mixer` is present.
  </verify>
  <done>
Handler __init__.py imports mixer module, triggering handler registration on FL Bridge startup.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Code review:**
   - `state.py` returns color in mixer track info
   - `mixer.py` has all 6 handlers with validation
   - `__init__.py` imports mixer module

2. **Static checks:**
   - Python files have no syntax errors (can verify via `python -m py_compile file.py` if Python available)

3. **Integration note:**
   These handlers cannot be tested until:
   - Files are synced to FL Studio runtime directory
   - FL Studio reloads the MIDI script
   - MCP tools are created (Plan 08-02) to call these handlers
</verification>

<success_criteria>
- [ ] `state.py` includes `'color': mixer.getTrackColor(i)` in track_info
- [ ] `mixer.py` exists with 6 handler functions
- [ ] Each handler validates index range
- [ ] mute/solo handlers use explicit 1/0, not -1 toggle
- [ ] `__init__.py` imports mixer module
- [ ] All Python files have valid syntax
</success_criteria>

<output>
After completion, create `.planning/phases/08-mixer-core/08-01-SUMMARY.md`
</output>
