---
phase: 04-generic-plugin-control
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/tools/plugins.ts
  - src/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "User can ask 'what parameters does this plugin have?' and get a filtered list of real parameter names"
    - "User can set any VST parameter by its name and the plugin responds"
    - "User can read parameter values reliably with shadow state fallback"
    - "Parameter name resolution is name-based, not index-based"
  artifacts:
    - path: "src/tools/plugins.ts"
      provides: "MCP tools: discover_plugin_params, get_plugin_param, set_plugin_param"
      exports: ["registerPluginTools"]
    - path: "src/tools/index.ts"
      provides: "Updated tool registration including plugin tools"
      contains: "registerPluginTools"
  key_links:
    - from: "src/tools/plugins.ts"
      to: "src/bridge/connection.ts"
      via: "connection.executeCommand for FL Bridge commands"
      pattern: "executeCommand\\('plugins\\."
    - from: "src/tools/plugins.ts"
      to: "src/plugins/param-cache.ts"
      via: "paramCache.store and paramCache.resolveParam"
      pattern: "paramCache\\."
    - from: "src/tools/plugins.ts"
      to: "src/plugins/shadow-state.ts"
      via: "shadowState.set and shadowState.get"
      pattern: "shadowState\\."
    - from: "src/tools/index.ts"
      to: "src/tools/plugins.ts"
      via: "import and call registerPluginTools"
      pattern: "registerPluginTools"
---

<objective>
Wire the plugin control system to MCP tools that users can invoke through natural language. Three tools: discover parameters, get a parameter by name, and set a parameter by name.

Purpose: This is the user-facing layer that makes plugin control accessible. The tools translate human-friendly parameter names into FL Studio parameter indices using the cache, maintain shadow state, and return formatted results. This completes all three requirements: PLUG-01 (discovery), PLUG-02 (get/set by name), PLUG-03 (shadow state).

Output: Three MCP tools registered and functional. Users can discover plugin parameters, read values, and set values by name.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-generic-plugin-control/04-RESEARCH.md
@.planning/phases/04-generic-plugin-control/04-02-SUMMARY.md

Key source files (patterns to follow):
@src/tools/state.ts
@src/tools/index.ts
@src/plugins/param-cache.ts
@src/plugins/shadow-state.ts
@src/plugins/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP plugin tools with cache and shadow state integration</name>
  <files>src/tools/plugins.ts</files>
  <action>
Create `src/tools/plugins.ts` following the pattern of `src/tools/state.ts`:

Export a function `registerPluginTools(server: McpServer, connection: ConnectionManager): void` that registers three tools:

**Tool 1: discover_plugin_params**
- Name: `'discover_plugin_params'`
- Description: `'Discover all named parameters of a loaded plugin. Returns real parameter names and current values, filtering out the thousands of blank VST parameter slots.'`
- Schema (zod):
  - `channelIndex`: z.number().int().min(0).optional().describe('Channel rack index. Omit to use the currently selected channel.')
  - `slotIndex`: z.number().int().min(-1).max(9).default(-1).describe('Mixer effect slot index. Use -1 (default) for channel rack plugins, 0-9 for mixer effect slots.')
  - `refresh`: z.boolean().default(false).describe('Force re-scan even if parameters are cached.')
- Handler:
  1. Check paramCache first (unless refresh=true). If cached, return cached data immediately without hitting FL Studio.
  2. If not cached (or refresh), call `connection.executeCommand('plugins.discover', { index: channelIndex, slotIndex })` with a 15000ms timeout (discovery can take a moment for 4240 iterations).
  3. If the FL Bridge response has success=false, return the error as text content.
  4. On success, extract the parameters array from the response. Store in paramCache via `paramCache.store(channelIndex, slotIndex, pluginName, params)`. Populate shadow state via `shadowState.populateFromDiscovery(channelIndex, slotIndex, params)`.
  5. Format response as text content with: plugin name, channel index, slot index, parameter count, and a table/list of parameter names with current values. Keep it human-readable -- this is what Claude will read to help the user.
  6. Note: if channelIndex was undefined (omitted), the FL Bridge returns the actual channelIndex used. Use that value for caching.

**Tool 2: get_plugin_param**
- Name: `'get_plugin_param'`
- Description: `'Get the current value of a plugin parameter by name. Uses fuzzy name matching (exact, prefix, or contains). Returns both the FL Studio live value and shadow state value if available.'`
- Schema (zod):
  - `name`: z.string().describe('Parameter name to look up (fuzzy matched). E.g., "Filter Cutoff", "Volume", "Osc1 Level".')
  - `channelIndex`: z.number().int().min(0).optional().describe('Channel rack index. Omit to use the currently selected channel.')
  - `slotIndex`: z.number().int().min(-1).max(9).default(-1).describe('Mixer effect slot index. Use -1 for channel rack plugins.')
- Handler:
  1. Resolve the parameter name to an index using `paramCache.resolveParam(channelIndex, slotIndex, name)`.
  2. If not found in cache, auto-discover first by calling the discover_plugin_params logic internally (call `connection.executeCommand('plugins.discover', ...)`, store in cache, then retry resolve).
  3. If still not found after discovery, return a helpful error: "Parameter '{name}' not found. Available parameters: {list first 20 cached param names}".
  4. Once resolved, call `connection.executeCommand('plugins.get_param', { paramIndex: resolved.index, index: channelIndex, slotIndex })`.
  5. Also check `shadowState.get(channelIndex, slotIndex, resolved.index)` for the shadow value.
  6. Return formatted text with: parameter name, FL Studio live value (0.0-1.0), display string if available, shadow value if different from live value (with source and timestamp).

**Tool 3: set_plugin_param**
- Name: `'set_plugin_param'`
- Description: `'Set a plugin parameter by name to a specific value. Value is normalized 0.0-1.0 (e.g., 0.75 = 75%). Uses fuzzy name matching.'`
- Schema (zod):
  - `name`: z.string().describe('Parameter name to set (fuzzy matched). E.g., "Filter Cutoff", "Volume".')
  - `value`: z.number().min(0).max(1).describe('Parameter value from 0.0 to 1.0 (normalized). E.g., 0.5 = 50%, 0.75 = 75%.')
  - `channelIndex`: z.number().int().min(0).optional().describe('Channel rack index. Omit to use the currently selected channel.')
  - `slotIndex`: z.number().int().min(-1).max(9).default(-1).describe('Mixer effect slot index. Use -1 for channel rack plugins.')
- Handler:
  1. Resolve parameter name using paramCache (same auto-discover pattern as get_plugin_param if not cached).
  2. If not found, return helpful error with available parameter names.
  3. Call `connection.executeCommand('plugins.set_param', { paramIndex: resolved.index, value, index: channelIndex, slotIndex })`.
  4. On success, update shadow state: `shadowState.set(channelIndex, slotIndex, resolved.index, value)`.
  5. Return formatted text confirming: parameter name, value set, read-back value from FL Studio, display string if available.

For all tools: handle the case where channelIndex is undefined by letting the FL Bridge use selectedChannel() -- but then extract the actual channelIndex from the response for caching purposes.

Import types: `import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'`, `import type { ConnectionManager } from '../bridge/connection.js'`, `import { z } from 'zod'`, `import { paramCache } from '../plugins/param-cache.js'`, `import { shadowState } from '../plugins/shadow-state.js'`, `import type { DiscoveredParam } from '../plugins/types.js'`.

IMPORTANT: Use .js extensions in all import paths (NodeNext module resolution).
  </action>
  <verify>
1. `npm run build` passes
2. File exports `registerPluginTools` function
3. Three tools registered: discover_plugin_params, get_plugin_param, set_plugin_param
4. All tools have zod schemas with proper types and descriptions
5. paramCache and shadowState are imported and used in handlers
6. Auto-discovery fallback exists in get and set tools (if cache miss, discover first)
7. Timeout for discover command is >= 10000ms (not the default 5000ms)
  </verify>
  <done>
Three MCP plugin tools created: discover_plugin_params (with caching), get_plugin_param (with name resolution and shadow state), set_plugin_param (with name resolution and shadow state update). All use paramCache for name-to-index resolution and shadowState for value tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register plugin tools in the tools index</name>
  <files>src/tools/index.ts</files>
  <action>
Update `src/tools/index.ts` to import and register plugin tools:

1. Add import: `import { registerPluginTools } from './plugins.js';`
2. Add call in `registerTools` function: `registerPluginTools(server, connection);`
3. Update the console.error log to include 'plugins' in the list of registered tools.

This is a small change -- just 3 lines modified in an existing file.
  </action>
  <verify>
1. `npm run build` passes
2. src/tools/index.ts imports registerPluginTools and calls it
3. Console log includes 'plugins'
  </verify>
  <done>
Plugin tools registered in the MCP server alongside existing tools (transport, state, patterns, notes, humanize).
  </done>
</task>

</tasks>

<verification>
- All three MCP tools are registered and callable
- discover_plugin_params returns filtered parameter list (not 4240 blank slots)
- get_plugin_param resolves names via fuzzy matching and returns live + shadow values
- set_plugin_param resolves names, sets value in FL Studio, and updates shadow state
- Auto-discovery triggers on cache miss (user doesn't need to manually discover first)
- `npm run build` passes with no errors
</verification>

<success_criteria>
- PLUG-01 satisfied: User can discover all named parameters of any loaded VST plugin
- PLUG-02 satisfied: User can get and set any VST parameter by name (not index)
- PLUG-03 satisfied: System maintains shadow state for all parameter changes
- All four phase success criteria from ROADMAP.md are met:
  1. Filtered parameter list (no blank slots)
  2. Set parameter by name works
  3. Shadow state fallback for unreliable getParamValue
  4. Name-based resolution (survives plugin version updates)
</success_criteria>

<output>
After completion, create `.planning/phases/04-generic-plugin-control/04-03-SUMMARY.md`
</output>
