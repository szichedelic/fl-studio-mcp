---
phase: 04-generic-plugin-control
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - fl-bridge/handlers/plugins.py
  - src/plugins/types.ts
  - src/plugins/param-cache.ts
  - src/plugins/shadow-state.ts
autonomous: true

must_haves:
  truths:
    - "FL Bridge can discover all named parameters of any loaded VST plugin, filtering out blank slots"
    - "FL Bridge can get a specific parameter's value by index"
    - "FL Bridge can set a specific parameter's value by index"
    - "TypeScript side caches parameter name-to-index mappings to avoid repeated 4240-slot scans"
    - "TypeScript side tracks shadow state for parameters set through MCP tools"
  artifacts:
    - path: "fl-bridge/handlers/plugins.py"
      provides: "Plugin discover, get_param, set_param command handlers"
      contains: "register_handler"
    - path: "src/plugins/types.ts"
      provides: "PluginParamInfo, CachedPlugin, ShadowValue interfaces"
      exports: ["PluginParamInfo", "CachedPlugin", "ShadowValue"]
    - path: "src/plugins/param-cache.ts"
      provides: "ParamCache class with name resolution (exact, prefix, contains)"
      exports: ["ParamCache", "paramCache"]
    - path: "src/plugins/shadow-state.ts"
      provides: "ShadowState class tracking values set through MCP"
      exports: ["ShadowState", "shadowState"]
  key_links:
    - from: "fl-bridge/handlers/plugins.py"
      to: "fl-bridge/protocol/commands.py"
      via: "register_handler for plugins.discover, plugins.get_param, plugins.set_param"
      pattern: "register_handler\\('plugins\\."
    - from: "src/plugins/param-cache.ts"
      to: "src/plugins/types.ts"
      via: "import PluginParamInfo, CachedPlugin"
      pattern: "import.*from.*types"
    - from: "src/plugins/shadow-state.ts"
      to: "src/plugins/types.ts"
      via: "import ShadowValue"
      pattern: "import.*from.*types"
---

<objective>
Build the plugin control backend: Python command handlers in FL Bridge that discover, get, and set plugin parameters, and TypeScript modules that cache parameter mappings and maintain shadow state.

Purpose: This creates the full data layer for plugin control. The Python handlers talk to FL Studio's `plugins` module. The TypeScript modules provide intelligent caching (avoid re-scanning 4240 slots) and shadow state (work around unreliable getParamValue).

Output: Three registered FL Bridge commands (plugins.discover, plugins.get_param, plugins.set_param) and three TypeScript modules (types, param-cache, shadow-state) ready for MCP tool wiring in Plan 03.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-generic-plugin-control/04-RESEARCH.md
@.planning/phases/04-generic-plugin-control/04-01-SUMMARY.md

Key source files (existing patterns):
@fl-bridge/handlers/transport.py
@fl-bridge/protocol/commands.py
@src/bridge/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python plugin handlers for FL Bridge</name>
  <files>fl-bridge/handlers/plugins.py</files>
  <action>
Create `fl-bridge/handlers/plugins.py` following the exact pattern of `fl-bridge/handlers/transport.py`:

1. Import FL Studio `plugins` and `channels` modules with try/except for test-mode safety (same pattern as transport.py imports `transport`).
2. Import `register_handler` from `protocol.commands`.

Implement three handlers:

**handle_plugin_discover(params)**
- Get `index` from params, default to `channels.selectedChannel()` if not provided
- Get `slotIndex` from params, default to -1 (channel rack plugin)
- Validate with `plugins.isValid(index, slotIndex)` -- return error dict if invalid
- Get plugin name via `plugins.getPluginName(index, slotIndex)`
- Get param count via `plugins.getParamCount(index, slotIndex)`
- Iterate all params (0 to param_count), call `plugins.getParamName(i, index, slotIndex)`
- Filter: only include params where `name and name.strip()` is truthy
- For each valid param, include `{'index': i, 'name': name, 'value': plugins.getParamValue(i, index, slotIndex)}`
- Return: `{'success': True, 'pluginName': plugin_name, 'channelIndex': index, 'slotIndex': slotIndex, 'totalSlots': param_count, 'parameterCount': len(discovered), 'parameters': discovered}`

**handle_plugin_get_param(params)**
- Required: `paramIndex` (int) -- return error if missing
- Get `index` from params, default to `channels.selectedChannel()`
- Get `slotIndex` from params, default to -1
- Validate plugin, validate paramIndex is in range (0 to getParamCount-1)
- Get name via `getParamName`, value via `getParamValue`, valueString via `getParamValueString` (wrap in try/except, some plugins don't support valueString -- return empty string on failure)
- Return: `{'success': True, 'paramIndex': paramIndex, 'name': name, 'value': value, 'valueString': valueString, 'channelIndex': index, 'slotIndex': slotIndex}`

**handle_plugin_set_param(params)**
- Required: `paramIndex` (int), `value` (float 0.0-1.0) -- return error if missing or out of range
- Get `index` from params, default to `channels.selectedChannel()`
- Get `slotIndex` from params, default to -1
- Validate plugin, validate paramIndex in range, validate value is 0.0-1.0
- Call `plugins.setParamValue(value, paramIndex, index, slotIndex)` -- note: value is the FIRST argument
- Read back with `getParamValue` and `getParamValueString` for confirmation
- Return: `{'success': True, 'paramIndex': paramIndex, 'value': value, 'readBack': readback_value, 'valueString': valueString, 'channelIndex': index, 'slotIndex': slotIndex}`

Register all three:
```python
register_handler('plugins.discover', handle_plugin_discover)
register_handler('plugins.get_param', handle_plugin_get_param)
register_handler('plugins.set_param', handle_plugin_set_param)
```

IMPORTANT: The `plugins.setParamValue` signature is `setParamValue(value, paramIndex, index, slotIndex)` -- value comes FIRST, not paramIndex. Double-check this against the research doc.

IMPORTANT: Wrap each handler body in try/except and return `{'success': False, 'error': str(e)}` on any exception (same pattern as transport handlers).
  </action>
  <verify>
1. Verify file exists and has correct imports
2. Verify all three handlers are registered with register_handler
3. Verify plugins module import is wrapped in try/except
4. Verify setParamValue argument order: value first, then paramIndex
5. Syntax check: `python -c "import ast; ast.parse(open('fl-bridge/handlers/plugins.py').read()); print('OK')"` (run from project root)
  </verify>
  <done>
Three FL Bridge command handlers registered: plugins.discover filters blank params from 4240 slots, plugins.get_param reads a single param by index, plugins.set_param writes a param value. All follow existing handler patterns with proper error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript plugin types, parameter cache, and shadow state modules</name>
  <files>src/plugins/types.ts, src/plugins/param-cache.ts, src/plugins/shadow-state.ts</files>
  <action>
Create the `src/plugins/` directory with three modules:

**src/plugins/types.ts**
Define interfaces:
```typescript
export interface PluginParamInfo {
  index: number;      // FL Studio parameter index (0-4239)
  name: string;       // Parameter display name
}

export interface DiscoveredParam extends PluginParamInfo {
  value: number;      // Current value 0.0-1.0 from discovery
}

export interface CachedPlugin {
  pluginName: string;
  channelIndex: number;
  slotIndex: number;
  params: DiscoveredParam[];
  paramsByName: Map<string, DiscoveredParam>;  // lowercase name -> info
  discoveredAt: number;  // Date.now()
}

export interface ShadowValue {
  value: number;       // 0.0 - 1.0
  setAt: number;       // Date.now()
  source: 'user' | 'discovered';
}
```

**src/plugins/param-cache.ts**
Create a `ParamCache` class that:
- Has a private `cache: Map<string, CachedPlugin>` keyed by `"channelIndex:slotIndex"`
- `private key(channelIndex: number, slotIndex: number): string` returns the cache key
- `store(channelIndex, slotIndex, pluginName, params: DiscoveredParam[]): void` -- builds the CachedPlugin with a paramsByName Map (lowercase name keys) and stores it
- `get(channelIndex, slotIndex): CachedPlugin | undefined` -- returns cached plugin if exists
- `resolveParam(channelIndex, slotIndex, name): DiscoveredParam | undefined` -- three-tier name resolution:
  1. Exact match: lowercase name lookup in paramsByName
  2. Prefix match: iterate paramsByName, check if key.startsWith(normalized) or normalized.startsWith(key)
  3. Contains match: iterate paramsByName, check if key.includes(normalized) or normalized.includes(key)
  Return first match found, or undefined.
- `invalidate(channelIndex?, slotIndex?): void` -- if both provided, delete that key; if neither provided, clear all
- `has(channelIndex, slotIndex): boolean` -- check if plugin is cached

Export a singleton instance: `export const paramCache = new ParamCache();`

**src/plugins/shadow-state.ts**
Create a `ShadowState` class that:
- Has a private `state: Map<string, ShadowValue>` keyed by `"channelIndex:slotIndex:paramIndex"`
- `private key(ch, slot, param): string` returns the key
- `set(ch, slot, param, value): void` -- stores with source='user', setAt=Date.now()
- `get(ch, slot, param): ShadowValue | undefined` -- returns shadow value if exists
- `populateFromDiscovery(ch, slot, params: Array<{index: number, value: number}>): void` -- for each param, only set if no existing entry OR existing entry has source='discovered' (user-set values are preserved)
- `clear(): void` -- clears all state

Export a singleton instance: `export const shadowState = new ShadowState();`

All files use ES module imports (import/export, .js extension in import paths for NodeNext resolution). Follow the project's TypeScript conventions from existing files (e.g., src/bridge/types.ts).
  </action>
  <verify>
1. `npm run build` passes with no TypeScript errors
2. Verify all three files exist in src/plugins/
3. Verify exports: types.ts exports interfaces, param-cache.ts exports ParamCache class + paramCache singleton, shadow-state.ts exports ShadowState class + shadowState singleton
4. Verify import paths use .js extension (NodeNext module resolution)
  </verify>
  <done>
Three TypeScript modules created: types.ts defines all plugin-related interfaces, param-cache.ts provides cached name-to-index resolution with three-tier fuzzy matching, shadow-state.ts tracks parameter values set through MCP with user/discovered source tracking. All export singleton instances ready for use by MCP tools.
  </done>
</task>

</tasks>

<verification>
- `plugins.discover` handler iterates all 4240 param slots and returns only named ones
- `plugins.get_param` reads a single parameter by index with value and display string
- `plugins.set_param` writes a parameter with correct argument order (value first)
- ParamCache resolves names via exact/prefix/contains matching (case-insensitive)
- ShadowState preserves user-set values over discovered values
- `npm run build` passes
- Python syntax check passes for plugins.py
</verification>

<success_criteria>
- FL Bridge responds to plugins.discover, plugins.get_param, plugins.set_param commands
- TypeScript ParamCache can store discovery results and resolve parameter names
- TypeScript ShadowState tracks set values and distinguishes user vs discovered sources
- All modules follow existing project patterns and conventions
</success_criteria>

<output>
After completion, create `.planning/phases/04-generic-plugin-control/04-02-SUMMARY.md`
</output>
