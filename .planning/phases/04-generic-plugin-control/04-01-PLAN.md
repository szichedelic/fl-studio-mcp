---
phase: 04-generic-plugin-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fl-bridge/protocol/sysex.py
  - fl-bridge/device_FLBridge.py
  - src/bridge/midi-client.ts
autonomous: true

must_haves:
  truths:
    - "FL Bridge can send responses larger than 2048 bytes without silent data loss"
    - "MCP server correctly reassembles multi-chunk SysEx responses into a single JSON object"
    - "Single-chunk responses (under 1800 bytes) continue to work unchanged"
  artifacts:
    - path: "fl-bridge/protocol/sysex.py"
      provides: "build_chunked_sysex_response function"
      contains: "def build_chunked_sysex_response"
    - path: "fl-bridge/device_FLBridge.py"
      provides: "Chunked response sending in OnSysEx"
      contains: "build_chunked_sysex_response"
    - path: "src/bridge/midi-client.ts"
      provides: "Chunk accumulation buffer and reassembly logic"
      contains: "chunkBuffers"
  key_links:
    - from: "fl-bridge/device_FLBridge.py"
      to: "fl-bridge/protocol/sysex.py"
      via: "import and call build_chunked_sysex_response"
      pattern: "build_chunked_sysex_response"
    - from: "src/bridge/midi-client.ts"
      to: "src/bridge/sysex-codec.ts"
      via: "SysExCodec.decode on reassembled message"
      pattern: "SysExCodec\\.decode"
---

<objective>
Add SysEx response chunking to the FL Bridge protocol layer so large payloads (like plugin parameter lists with 100+ entries) can be sent from FL Studio to the MCP server without hitting the node-midi 2048-byte RtMidi buffer limit.

Purpose: This is the critical infrastructure prerequisite for all plugin control. Without chunking, parameter discovery responses are silently dropped by node-midi when they exceed 2048 bytes. A typical VST with 100+ named parameters produces ~6000+ bytes.

Output: Modified protocol layer that transparently chunks large responses on the Python side and reassembles them on the TypeScript side. Existing single-chunk responses remain unchanged.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-generic-plugin-control/04-RESEARCH.md

Key source files:
@fl-bridge/protocol/sysex.py
@fl-bridge/device_FLBridge.py
@src/bridge/midi-client.ts
@src/bridge/sysex-codec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add chunked SysEx response building (Python) and update FL Bridge sender</name>
  <files>fl-bridge/protocol/sysex.py, fl-bridge/device_FLBridge.py</files>
  <action>
In `fl-bridge/protocol/sysex.py`, add a new function `build_chunked_sysex_response(client_id, response, success=True)` that:

1. JSON-encodes the response, base64-encodes it (same as existing `build_sysex_response`)
2. If the base64 string is <= MAX_PAYLOAD_BYTES (1800), returns a list containing one message (identical to current behavior -- continuation byte = 0x00)
3. If the base64 string exceeds MAX_PAYLOAD_BYTES, splits it into chunks of MAX_PAYLOAD_BYTES characters each
4. Each chunk becomes a SysEx message with the same header format: [F0, 7D, ORIGIN_SERVER, client_id & 0x7F, continuation, MSG_TYPE_RESPONSE, status, ...payload_chars, F7]
5. continuation byte = 0x01 for all chunks except the last, which gets 0x00
6. Returns a list of message lists (List[List[int]])

Add `MAX_PAYLOAD_BYTES = 1800` as a module constant near the other constants.

The existing `build_sysex_response` function must NOT be modified or removed -- it's used by other code and continues to work for small responses.

In `fl-bridge/device_FLBridge.py`, modify the OnSysEx function's response-sending block (lines ~248-258). Replace the current pattern:
```python
sysex_bytes = _sysex.build_sysex_response(...)
device.midiOutSysex(bytes(sysex_bytes))
```

With the chunked pattern:
```python
chunks = _sysex.build_chunked_sysex_response(
    client_id=parsed['client_id'],
    response=result,
    success=result.get('success', True)
)
for chunk in chunks:
    device.midiOutSysex(bytes(chunk))
```

Keep the same try/except error handling. Keep all the debug print statements. Also update the `from handlers import ...` line in OnInit to include `plugins` (it will be created in Plan 02, but we add the import now -- use a separate try/except so if the module doesn't exist yet, the other handlers still load).

Specifically, change the handler import block in OnInit from:
```python
from handlers import transport, state, patterns, pianoroll
```
to:
```python
from handlers import transport, state, patterns, pianoroll
try:
    from handlers import plugins
    print("FL Bridge: Plugin handlers registered")
except ImportError:
    print("FL Bridge: Plugin handlers not yet available")
```

Also update the `fl-bridge/handlers/__init__.py` to add a conditional import of plugins:
```python
try:
    from handlers import plugins
except ImportError:
    pass  # plugins handler not yet created
```
  </action>
  <verify>
1. Open a Python shell and test: `from protocol.sysex import build_chunked_sysex_response; chunks = build_chunked_sysex_response(1, {'params': [{'name': f'Param {i}', 'index': i, 'value': 0.5} for i in range(200)]}); print(f'{len(chunks)} chunks, sizes: {[len(c) for c in chunks]}')`
2. Verify single small response returns exactly 1 chunk: `chunks = build_chunked_sysex_response(1, {'success': True}); assert len(chunks) == 1`
3. Verify continuation bytes: for multi-chunk, all but last have byte[4]=0x01, last has byte[4]=0x00
4. `npm run build` passes (TypeScript compilation still works)
  </verify>
  <done>
build_chunked_sysex_response exists in sysex.py and correctly splits large payloads into multiple SysEx messages under 1808 bytes each (1800 payload + 8 header). device_FLBridge.py uses chunked sending. Small responses produce exactly 1 chunk (backward compatible).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add chunk accumulation and reassembly (TypeScript)</name>
  <files>src/bridge/midi-client.ts</files>
  <action>
In `src/bridge/midi-client.ts`, add chunk accumulation logic to the `MidiClient` class:

1. Add a private property: `private chunkBuffers: Map<number, number[][]> = new Map();`
   This maps clientId -> array of payload byte arrays (one per accumulated chunk).

2. Modify `handleMessage(deltaTime, message)` to handle chunking:
   - After the existing `SysExCodec.isValid(message)` check, extract the continuation byte: `const continuation = message[4];`
   - Extract the clientId: `const clientId = message[3];`
   - If `continuation === 0x01` (more chunks coming):
     - Extract payload bytes from the chunk: `message.slice(7, -1)` (bytes between header and F7)
     - Get or create the buffer array for this clientId in `chunkBuffers`
     - Push the payload bytes into the buffer
     - Add a debug log: `debugLog(\`RX [${clientId}] chunk ${buffer.length} accumulated (${payloadBytes.length} bytes)\`);`
     - Return early (do NOT try to decode or resolve)
   - If `continuation === 0x00` (final or only chunk):
     - Check if there are accumulated chunks in `chunkBuffers` for this clientId
     - If yes: combine all accumulated payload bytes + this final chunk's payload bytes into one array. Build a synthetic complete message: `[...message.slice(0, 7), ...combinedPayload, 0xF7]`. Delete the buffer entry. Use this synthetic message for decoding.
     - If no: this is a single-chunk message, proceed with the original message as-is (existing behavior)
   - After reassembly (if needed), proceed with the existing `SysExCodec.decode(message)` and pending request resolution logic

3. Add cleanup in `disconnect()`: call `this.chunkBuffers.clear()` to prevent memory leaks.

IMPORTANT: Do NOT modify `SysExCodec` (sysex-codec.ts). The codec already handles any valid SysEx message -- it just needs to receive the full reassembled message. All chunking logic lives in MidiClient.

IMPORTANT: The existing `handleMessage` code checks `message[0] !== 0xf0` before `SysExCodec.isValid`. Keep that check. Insert the chunking logic AFTER the isValid check but BEFORE the `SysExCodec.decode` call.
  </action>
  <verify>
1. `npm run build` succeeds with no TypeScript errors
2. Manual code review: `chunkBuffers` property exists, `handleMessage` has continuation byte branching, `disconnect` clears chunk buffers
3. Verify the reassembly logic: when continuation=0x01, payload is buffered and method returns early. When continuation=0x00 with buffered chunks, a synthetic message is constructed from all chunks.
  </verify>
  <done>
MidiClient accumulates chunked SysEx responses and reassembles them into complete messages before decoding. Single-chunk messages pass through unchanged. Chunk buffers are cleared on disconnect.
  </done>
</task>

</tasks>

<verification>
- `build_chunked_sysex_response` produces correct SysEx framing for both single and multi-chunk responses
- Continuation byte (position 4) is 0x01 for intermediate chunks, 0x00 for final
- Each chunk is under 1808 bytes total (1800 payload + 8 header/footer)
- TypeScript chunk accumulation correctly reassembles multi-chunk responses
- Existing single-message protocol flow is completely unchanged
- `npm run build` passes
</verification>

<success_criteria>
- Large JSON payloads (6000+ bytes) are transparently chunked into multiple SysEx messages under 2048 bytes each
- Small payloads produce exactly 1 SysEx message (no behavioral change)
- The MCP server reassembles chunked responses into a single FLResponse object
- All existing commands (transport, state, patterns, pianoroll) continue working unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/04-generic-plugin-control/04-01-SUMMARY.md`
</output>
