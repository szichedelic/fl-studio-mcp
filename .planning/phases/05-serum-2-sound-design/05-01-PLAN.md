---
phase: 05-serum-2-sound-design
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/plugins/serum/types.ts
  - src/plugins/serum/aliases.ts
autonomous: false

must_haves:
  truths:
    - "Actual Serum 2 parameter names from FL Studio are captured and documented"
    - "A SemanticAlias interface and resolveSemanticAlias function exist that translate musical language to actual Serum 2 parameter names"
  artifacts:
    - path: "src/plugins/serum/types.ts"
      provides: "Serum-specific TypeScript types (SemanticAlias, SoundRecipe, SerumPresetInfo)"
      contains: "SemanticAlias"
    - path: "src/plugins/serum/aliases.ts"
      provides: "Semantic alias map and resolution function populated with real parameter names"
      exports: ["resolveSemanticAlias", "SERUM_ALIASES"]
  key_links:
    - from: "src/plugins/serum/aliases.ts"
      to: "src/plugins/param-cache.ts"
      via: "Alias resolution runs BEFORE Phase 4 fuzzy matching as a pre-lookup step"
      pattern: "resolveSemanticAlias"
---

<objective>
Run the Serum 2 discovery spike to capture actual parameter names from FL Studio, then build the Serum-specific types and semantic alias map using that real data.

Purpose: Everything in Phase 5 depends on knowing Serum 2's actual FL Studio parameter names. This plan captures that data via a human checkpoint, then creates the foundational types and alias resolution layer that all subsequent Serum tools use.

Output: `src/plugins/serum/types.ts` with Serum-specific interfaces, and `src/plugins/serum/aliases.ts` with a populated alias map and resolveSemanticAlias() function.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-serum-2-sound-design/05-RESEARCH.md
@src/plugins/types.ts
@src/plugins/param-cache.ts
@src/tools/plugins.ts
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: Run Serum 2 parameter discovery in FL Studio</name>
  <action>
    The user must run the `discover_plugin_params` MCP tool on a channel that has Serum 2 loaded.
    This captures the actual parameter names as reported by FL Studio's plugins.getParamName() API.

    Steps:
    1. Open FL Studio with a project that has Serum 2 loaded on a channel
    2. In Claude, use the `discover_plugin_params` tool (with refresh: true if already cached)
    3. Copy the FULL output (all parameter names and values)
    4. Paste the output here

    This data is essential -- every alias, recipe, and tool in Phase 5 references these exact parameter names.
    Without this data, all parameter name references would be guesses.

    We also need to test these FL Studio preset API functions:
    - Does `discover_plugin_params` show the plugin name as "Serum 2" or something else?
    - How many named parameters does it report?
    - What naming convention do the parameters use? (e.g., "Osc A Level" vs "a_vol" vs "A Level")

    If possible, also test preset navigation:
    - Ask Claude to run: `plugins.getPresetCount()` for the Serum 2 channel
    - Ask Claude to run: `plugins.nextPreset()` then `plugins.getName()` with FPN_Preset flag
    - Report whether preset navigation works or not
  </action>
  <resume-signal>Paste the full discover_plugin_params output for Serum 2, plus results of preset API testing. Type "skip-discovery" if you want to proceed with placeholder names (NOT recommended).</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Create Serum types and semantic alias map from discovered data</name>
  <files>src/plugins/serum/types.ts, src/plugins/serum/aliases.ts</files>
  <action>
    Using the parameter names from the discovery spike output:

    **File 1: src/plugins/serum/types.ts**
    Create Serum-specific TypeScript interfaces:

    ```typescript
    export interface SemanticAlias {
      semantic: string[];        // Human-friendly names (multiple per param)
      actual: string;            // Actual FL Studio parameter name (from discovery)
      group: string;             // Logical group: 'oscillator-a', 'oscillator-b', 'oscillator-c', 'sub', 'noise', 'filter-1', 'filter-2', 'envelope-1'..'envelope-4', 'lfo', 'fx', 'macros', 'global'
      description?: string;      // What this parameter does
    }

    export interface SoundRecipe {
      name: string;
      description: string;
      category: 'pad' | 'lead' | 'bass' | 'pluck' | 'keys' | 'fx';
      parameters: Record<string, number>;  // semantic param name -> value 0.0-1.0
      tags?: string[];
    }

    export interface SerumPresetInfo {
      name: string;          // Filename without extension
      path: string;          // Full path
      category: string;      // Parent folder name
      extension: string;     // .fxp or .SerumPreset
    }
    ```

    **File 2: src/plugins/serum/aliases.ts**
    Build the semantic alias map from the ACTUAL discovered parameter names.

    For each discovered parameter name:
    - Map it to 2-4 human-friendly semantic aliases
    - Group by logical category (oscillator, filter, envelope, lfo, fx, macros)
    - Cover the most important parameters first (oscillator levels, filter cutoff/resonance, envelope ADSR, macros, FX)

    Priority parameters to alias (if they exist in discovery data):
    1. Oscillator A/B/C: level, wavetable position, unison voices, unison detune, octave, semi, fine, pan
    2. Sub oscillator: level, shape
    3. Noise oscillator: level
    4. Filter 1/2: cutoff, resonance, type, drive
    5. Envelopes 1-4: attack, decay, sustain, release
    6. LFOs 1-4 (at minimum): rate, phase, amount
    7. Macros 1-4 (at minimum)
    8. FX: reverb mix/size, delay mix/time, chorus rate/depth
    9. Global: master volume

    Export:
    - `SERUM_ALIASES: SemanticAlias[]` - the full alias table
    - `resolveSemanticAlias(input: string): string` - returns the actual FL Studio param name if a semantic match is found, otherwise returns the input unchanged for Phase 4 fallthrough
    - `getAliasGroups(): string[]` - returns list of unique group names for browsing

    The resolveSemanticAlias function:
    1. Normalize input to lowercase + trim
    2. Search SERUM_ALIASES for a semantic match
    3. If found, return the `actual` parameter name
    4. If not found, return the input unchanged (Phase 4's fuzzy matcher will handle it)

    IMPORTANT: Use the EXACT parameter names from the discovery spike output in the `actual` field. Do NOT guess or use Serum 1 naming conventions.
  </action>
  <verify>
    - `npm run build` passes with no errors
    - `src/plugins/serum/types.ts` exports SemanticAlias, SoundRecipe, SerumPresetInfo interfaces
    - `src/plugins/serum/aliases.ts` exports SERUM_ALIASES array with 50+ entries, resolveSemanticAlias function, getAliasGroups function
    - All alias `actual` values match real discovered parameter names
  </verify>
  <done>
    Serum types and semantic alias map exist with real parameter names from discovery spike. resolveSemanticAlias("filter cutoff") returns the actual Serum 2 parameter name. At least 50 aliases covering oscillators, filters, envelopes, LFOs, macros, and FX.
  </done>
</task>

</tasks>

<verification>
- src/plugins/serum/types.ts exists and exports SemanticAlias, SoundRecipe, SerumPresetInfo
- src/plugins/serum/aliases.ts exists and exports SERUM_ALIASES, resolveSemanticAlias, getAliasGroups
- resolveSemanticAlias returns actual FL Studio parameter names, not guessed names
- npm run build succeeds
</verification>

<success_criteria>
- Serum 2 parameter names captured from FL Studio runtime discovery
- SemanticAlias interface defined with semantic[], actual, group, description fields
- SERUM_ALIASES array contains 50+ entries covering all major Serum 2 parameter groups
- resolveSemanticAlias correctly maps human-friendly names to actual FL Studio parameter names
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-serum-2-sound-design/05-01-SUMMARY.md`
</output>
