---
phase: 03-humanization-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/music/types.ts
  - src/music/humanize/util.ts
  - src/music/humanize/swing.ts
  - src/music/humanize/timing.ts
autonomous: true

must_haves:
  truths:
    - "Ornstein-Uhlenbeck timing drift produces correlated offsets that mean-revert toward zero"
    - "MPC-style swing shifts only off-beat subdivisions by the correct ratio"
    - "Gaussian RNG produces normally distributed values via Box-Muller transform"
    - "Context-aware sigma scales tighter for dense passages and looser for sparse passages"
  artifacts:
    - path: "src/music/types.ts"
      provides: "HumanizationParams, TimingDriftParams, SwingParams, VelocityParams, NoteLengthParams, InstrumentProfile types"
      contains: "HumanizationParams"
    - path: "src/music/humanize/util.ts"
      provides: "gaussianRandom, createSeededRng, clampVelocity helpers"
      exports: ["gaussianRandom", "clampVelocity"]
    - path: "src/music/humanize/swing.ts"
      provides: "MPC-style swing transform with grid tolerance"
      exports: ["applySwing"]
    - path: "src/music/humanize/timing.ts"
      provides: "Ornstein-Uhlenbeck timing drift with context-aware scaling"
      exports: ["applyTimingDrift"]
  key_links:
    - from: "src/music/humanize/timing.ts"
      to: "src/music/humanize/util.ts"
      via: "import gaussianRandom"
      pattern: "import.*gaussianRandom.*from.*util"
    - from: "src/music/humanize/swing.ts"
      to: "src/music/types.ts"
      via: "import NoteData"
      pattern: "import.*NoteData.*from.*types"
---

<objective>
Create the humanization engine foundation: install dependencies, define all humanization types, build utility functions, and implement the two timing-related transforms (swing and Brownian drift).

Purpose: Establishes the type system and the most algorithmically critical transforms -- timing drift (Ornstein-Uhlenbeck) and swing (MPC-style). These define how notes move in time, which is the foundation of humanization.

Output: Four new/modified files -- updated types.ts with all humanization interfaces, util.ts with RNG helpers, swing.ts with MPC swing, timing.ts with O-U timing drift and context-aware scaling.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-humanization-engine/03-RESEARCH.md

@src/music/types.ts
@src/music/melody.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and add humanization types</name>
  <files>package.json, src/music/types.ts, src/music/humanize/util.ts</files>
  <action>
1. Install simplex-noise and alea:
   ```
   npm install simplex-noise@4.0.3 alea@1.0.1
   ```

2. Add the following types to the BOTTOM of `src/music/types.ts` (do NOT modify existing types):

```typescript
// ── Humanization Types ────────────────────────────────────────────────

export interface TimingDriftParams {
  enabled?: boolean;
  /** Mean reversion speed (0.1=slow drift, 0.9=tight). Default 0.5 */
  theta?: number;
  /** Drift magnitude in beats (0.001=subtle, 0.03=loose). Default 0.008 */
  sigma?: number;
  /** Scale sigma by local note density. Default false */
  contextAware?: boolean;
}

export interface SwingParams {
  enabled?: boolean;
  /** Swing amount 50 (none) to 75 (max). 66 = triplet feel. Default 50 */
  amount?: number;
  /** Grid subdivision: 0.25 = 16ths, 0.5 = 8ths. Default 0.25 */
  gridSize?: number;
}

export interface VelocityParams {
  enabled?: boolean;
  /** Instrument profile for velocity shaping */
  instrument?: 'drums' | 'piano' | 'bass' | 'synth' | 'default';
  /** Overall variation amount 0-1. Default 0.5 */
  amount?: number;
  /** Emphasize downbeats. Default true */
  beatEmphasis?: boolean;
}

export interface NoteLengthParams {
  enabled?: boolean;
  /** Variation amount 0-1. Default 0.3 */
  amount?: number;
  /** Downbeats slightly longer (legato). Default true */
  downbeatLegato?: boolean;
}

export type HumanizationPreset = 'tight' | 'loose' | 'jazz' | 'lo-fi';

export interface HumanizationParams {
  /** Optional seed for reproducible results. Auto-generated if omitted */
  seed?: string;
  /** Named preset (overrides individual params) */
  preset?: HumanizationPreset;
  timing?: TimingDriftParams;
  velocity?: VelocityParams;
  swing?: SwingParams;
  noteLength?: NoteLengthParams;
}

/** Result from humanize() -- notes plus metadata */
export interface HumanizationResult {
  notes: NoteData[];
  /** The seed used (for reproducibility) */
  seed: string;
  /** Which transforms were applied */
  applied: string[];
}
```

3. Create `src/music/humanize/util.ts` with these utilities:

- `gaussianRandom(mean?: number, stddev?: number): number` -- Box-Muller transform. Use Math.random() by default, but accept an optional `rng: () => number` parameter so seeded PRNG can be injected.
- `clampVelocity(v: number): number` -- Clamp to [0, 1] range and round to 3 decimal places.
- `clampTime(t: number): number` -- Ensure time >= 0 and round to 3 decimal places.
- `createSeededRng(seed: string): () => number` -- Wraps `alea` to create a seeded PRNG function. Import alea with: `import alea from 'alea';`
- `getBeatPosition(time: number, tolerance?: number): { isDownbeat: boolean; isBackbeat: boolean; isOffbeat: boolean; subdivIndex: number }` -- Classifies a time value's position within the beat using epsilon-based comparison (default tolerance 0.01 beats). Downbeat = beat 0 or 2 within a 4-beat bar. Backbeat = beat 1 or 3. Offbeat = subdivisions between beats (16th note positions).

IMPORTANT: All functions must use the `.js` extension in imports (NodeNext module resolution). E.g., `import type { NoteData } from '../types.js';`
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with zero errors. Verify simplex-noise and alea appear in package.json dependencies.
  </verify>
  <done>
types.ts has all humanization interfaces (HumanizationParams, TimingDriftParams, SwingParams, VelocityParams, NoteLengthParams, HumanizationPreset, HumanizationResult). util.ts exports gaussianRandom, clampVelocity, clampTime, createSeededRng, getBeatPosition. Both simplex-noise@4.0.3 and alea@1.0.1 are installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement MPC-style swing and Ornstein-Uhlenbeck timing drift</name>
  <files>src/music/humanize/swing.ts, src/music/humanize/timing.ts</files>
  <action>
1. Create `src/music/humanize/swing.ts`:

Export a single function `applySwing(notes: NoteData[], params?: SwingParams, rng?: () => number): NoteData[]`.

Implementation based on Roger Linn MPC formula from RESEARCH.md:
- Default params: `{ enabled: true, amount: 50, gridSize: 0.25 }`
- If `amount <= 50` or `enabled === false`, return shallow copies of notes (no mutation).
- Calculate `swingRatio = (amount - 50) / 25` (0.0 to 1.0 range).
- Calculate `maxDelay = gridSize * swingRatio`.
- Use a `tolerance = gridSize * 0.1` for grid point detection (handles floating-point imprecision).
- For each note, find its position within a pair of subdivisions (`pairSize = gridSize * 2`). Use `posInPair = ((note.time % pairSize) + pairSize) % pairSize` to handle negative modulo correctly.
- A note is "off-beat" if `Math.abs(posInPair - gridSize) < tolerance`.
- Off-beat notes get their time shifted by `+maxDelay`. On-beat notes are copied unchanged.
- ALWAYS spread-copy notes (`{ ...note }`), never mutate input array.
- Clamp resulting time values with `clampTime()`.

2. Create `src/music/humanize/timing.ts`:

Export two functions:
- `applyTimingDrift(notes: NoteData[], params?: TimingDriftParams, rng?: () => number): NoteData[]`
- `calculateContextSigmas(notes: NoteData[], baseSigma: number): number[]` (exported for testing, used internally)

`applyTimingDrift` implementation:
- Default params: `{ enabled: true, theta: 0.5, sigma: 0.008, contextAware: false }`
- If `enabled === false`, return shallow copies.
- Sort notes by time (work on a copy).
- If `contextAware` is true, call `calculateContextSigmas` to get per-note sigma values. Otherwise use uniform `sigma` for all notes.
- Generate timing offsets using Ornstein-Uhlenbeck (Euler-Maruyama discretization):
  ```
  x_{n+1} = x_n + theta * (0 - x_n) * dt + sigma_n * sqrt(dt) * gaussianRandom(0, 1, rng)
  ```
  where `dt = 1.0` (one step per note), `sigma_n` is either uniform or context-scaled.
- Start with `x = 0` (first note on grid).
- Apply each offset: `note.time = clampTime(note.time + offsets[i])`.
- Return notes in their original order (re-sort by original index if needed).

`calculateContextSigmas` implementation (from RESEARCH.md Pattern: Context-Aware):
- For each note, count neighbors within a 2-beat window (`note.time - 2` to `note.time + 2`).
- Scale factor: density <= 3 -> 1.5x sigma (loose), 4-8 -> 1.0x (normal), 9+ -> 0.5x (tight).
- Return array of per-note sigma values.

Both functions must accept an optional `rng` parameter for deterministic behavior with seeded PRNG. If not provided, `gaussianRandom` uses `Math.random`.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with zero errors. Verify both files export their functions correctly by checking the TypeScript compilation succeeds with the import paths.
  </verify>
  <done>
swing.ts exports `applySwing` implementing MPC-style swing with grid tolerance and subdivision detection. timing.ts exports `applyTimingDrift` implementing Ornstein-Uhlenbeck process with optional context-aware sigma scaling. Both accept seeded RNG for reproducibility. Both use spread-copy (no mutation of input arrays).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles with zero errors
2. All new files use `.js` extension in import paths (NodeNext resolution)
3. No existing files broken -- only types.ts gets additions at the bottom
4. `package.json` shows simplex-noise@4.0.3 and alea@1.0.1 in dependencies
</verification>

<success_criteria>
- HumanizationParams and all sub-types exist in types.ts
- util.ts provides gaussianRandom (Box-Muller), clampVelocity, clampTime, createSeededRng, getBeatPosition
- swing.ts applies MPC-style swing with floating-point-safe grid detection
- timing.ts applies Ornstein-Uhlenbeck timing drift with optional context-aware scaling
- Project compiles cleanly with `npx tsc --noEmit`
</success_criteria>

<output>
After completion, create `.planning/phases/03-humanization-engine/03-01-SUMMARY.md`
</output>
