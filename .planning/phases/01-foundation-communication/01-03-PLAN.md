---
phase: 01-foundation-communication
plan: 03
type: execute
wave: 2
depends_on: [01-01, 01-02]
files_modified:
  - src/index.ts
  - src/tools/transport.ts
  - src/tools/state.ts
  - src/tools/patterns.ts
  - src/tools/index.ts
  - fl-bridge/handlers/__init__.py
  - fl-bridge/handlers/transport.py
  - fl-bridge/handlers/state.py
  - fl-bridge/handlers/patterns.py
  - fl-bridge/device_FLBridge.py
autonomous: false

user_setup:
  - service: loopMIDI
    why: "Virtual MIDI ports for FL Studio communication"
    env_vars: []
    dashboard_config:
      - task: "Install loopMIDI from https://www.tobias-erichsen.de/software/loopmidi.html"
        location: "Windows installer"
      - task: "Create two virtual MIDI ports: 'FL Bridge In' and 'FL Bridge Out'"
        location: "loopMIDI application"
      - task: "In FL Studio: Options > MIDI Settings > assign FL Bridge In as input, FL Bridge Out as output to the FLBridge script"
        location: "FL Studio MIDI Settings"

must_haves:
  truths:
    - "User can start MCP server and it connects to FL Studio"
    - "User can control transport (play/stop) via MCP tool"
    - "User can query project state (patterns, channels, mixer) and get accurate response"
    - "User can select and create patterns via MCP tool"
  artifacts:
    - path: "src/tools/transport.ts"
      provides: "Transport control tools"
      exports: ["registerTransportTools"]
    - path: "src/tools/state.ts"
      provides: "State reading tools"
      exports: ["registerStateTools"]
    - path: "src/tools/patterns.ts"
      provides: "Pattern operation tools"
      exports: ["registerPatternTools"]
    - path: "fl-bridge/handlers/transport.py"
      provides: "Transport command handlers"
      contains: "def handle_transport"
    - path: "fl-bridge/handlers/state.py"
      provides: "State reading handlers"
      contains: "def handle_get"
    - path: "fl-bridge/handlers/patterns.py"
      provides: "Pattern operation handlers"
      contains: "def handle_pattern"
  key_links:
    - from: "src/index.ts"
      to: "src/tools/index.ts"
      via: "import and register all tools"
      pattern: "registerTools"
    - from: "src/tools/transport.ts"
      to: "src/bridge/connection.ts"
      via: "uses ConnectionManager to send commands"
      pattern: "connectionManager.executeCommand"
    - from: "fl-bridge/device_FLBridge.py"
      to: "fl-bridge/handlers/"
      via: "imports handlers to register them"
      pattern: "from handlers import"
---

<objective>
Wire up MCP tools for transport control, state reading, and pattern operations. Implement corresponding FL Bridge handlers. Verify end-to-end communication with FL Studio.

Purpose: This completes Phase 1 by connecting all the pieces. After this plan, users can actually control FL Studio via natural language.

Output: Working MCP server with transport, state, and pattern tools that communicate with FL Studio via the FL Bridge.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-communication/01-RESEARCH.md
@.planning/phases/01-foundation-communication/01-01-SUMMARY.md
@.planning/phases/01-foundation-communication/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FL Bridge command handlers</name>
  <files>fl-bridge/handlers/__init__.py, fl-bridge/handlers/transport.py, fl-bridge/handlers/state.py, fl-bridge/handlers/patterns.py, fl-bridge/device_FLBridge.py</files>
  <action>
1. Create fl-bridge/handlers/__init__.py:
   - Import all handler modules to trigger registration
   - from handlers import transport, state, patterns

2. Create fl-bridge/handlers/transport.py:
   - Import transport from FL Studio API
   - Import register_handler from protocol.commands

   - def handle_transport_start(params: dict) -> dict:
     - Call transport.start()
     - Return { 'success': True, 'playing': transport.isPlaying() }
     - Wrap in try/except, return error on failure

   - def handle_transport_stop(params: dict) -> dict:
     - Call transport.stop()
     - Return { 'success': True, 'playing': False }

   - def handle_transport_record(params: dict) -> dict:
     - Call transport.record()
     - Return { 'success': True, 'recording': transport.isRecording() }

   - def handle_transport_state(params: dict) -> dict:
     - Return {
         'playing': transport.isPlaying(),
         'recording': transport.isRecording(),
         'songPosition': transport.getSongPos(4),  # Bars:Steps:Ticks
         'loopMode': transport.getLoopMode()
       }

   - Register all handlers:
     - register_handler('transport.start', handle_transport_start)
     - register_handler('transport.stop', handle_transport_stop)
     - register_handler('transport.record', handle_transport_record)
     - register_handler('transport.state', handle_transport_state)

3. Create fl-bridge/handlers/state.py:
   - Import channels, mixer, patterns from FL Studio API
   - Import register_handler

   - def handle_get_channels(params: dict) -> dict:
     - count = channels.channelCount()
     - Build list of channel info (index, name, type, volume, pan, muted, selected, targetMixer)
     - Return { 'success': True, 'channels': [...] }

   - def handle_get_mixer(params: dict) -> dict:
     - count = mixer.trackCount()
     - Build list of track info (index, name, volume, pan, muted, solo)
     - Include current tempo
     - Return { 'success': True, 'tracks': [...], 'tempo': mixer.getCurrentTempo() }

   - def handle_get_patterns(params: dict) -> dict:
     - count = patterns.patternCount()
     - Build list of non-default patterns (index, name, length, color, selected)
     - Return { 'success': True, 'patterns': [...], 'currentPattern': patterns.patternNumber() }

   - Register handlers:
     - register_handler('state.channels', handle_get_channels)
     - register_handler('state.mixer', handle_get_mixer)
     - register_handler('state.patterns', handle_get_patterns)

4. Create fl-bridge/handlers/patterns.py:
   - Import patterns from FL Studio API
   - Import register_handler

   - def handle_pattern_select(params: dict) -> dict:
     - index = params.get('index', 1)
     - Call patterns.jumpToPattern(index)
     - Return { 'success': True, 'currentPattern': patterns.patternNumber() }

   - def handle_pattern_create(params: dict) -> dict:
     - Call patterns.findFirstNextEmptyPat(0)
     - Return { 'success': True, 'currentPattern': patterns.patternNumber() }

   - def handle_pattern_rename(params: dict) -> dict:
     - index = params.get('index', patterns.patternNumber())
     - name = params.get('name', 'New Pattern')
     - Call patterns.setPatternName(index, name)
     - Return { 'success': True, 'index': index, 'name': name }

   - Register handlers:
     - register_handler('pattern.select', handle_pattern_select)
     - register_handler('pattern.create', handle_pattern_create)
     - register_handler('pattern.rename', handle_pattern_rename)

5. Update fl-bridge/device_FLBridge.py:
   - In OnInit(), add: from handlers import transport, state, patterns
   - This triggers handler registration when FL Studio loads the script
   - Keep the import inside OnInit() wrapped in try/except for safety
  </action>
  <verify>
Python syntax check all handler files:
- `python -m py_compile fl-bridge/handlers/transport.py`
- `python -m py_compile fl-bridge/handlers/state.py`
- `python -m py_compile fl-bridge/handlers/patterns.py`
  </verify>
  <done>
All handler files exist and pass syntax checking.
Handlers are registered via register_handler().
device_FLBridge.py imports handlers in OnInit().
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement MCP tools</name>
  <files>src/tools/transport.ts, src/tools/state.ts, src/tools/patterns.ts, src/tools/index.ts, src/index.ts</files>
  <action>
1. Create src/tools/transport.ts:
   - Import McpServer type
   - Import ConnectionManager from bridge/connection

   - export function registerTransportTools(server: McpServer, connection: ConnectionManager):

     - server.tool("transport_play", { description: "Start playback in FL Studio" }, async () => {
         const result = await connection.executeCommand('transport.start', {});
         return { content: [{ type: "text", text: JSON.stringify(result) }] };
       });

     - server.tool("transport_stop", { description: "Stop playback in FL Studio" }, async () => {
         const result = await connection.executeCommand('transport.stop', {});
         return { content: [{ type: "text", text: JSON.stringify(result) }] };
       });

     - server.tool("transport_record", { description: "Toggle recording in FL Studio" }, async () => {
         const result = await connection.executeCommand('transport.record', {});
         return { content: [{ type: "text", text: JSON.stringify(result) }] };
       });

     - server.tool("transport_state", { description: "Get current transport state (playing, recording, position)" }, async () => {
         const result = await connection.executeCommand('transport.state', {});
         return { content: [{ type: "text", text: JSON.stringify(result) }] };
       });

2. Create src/tools/state.ts:
   - Similar structure

   - server.tool("get_channels", { description: "Get all channels in the channel rack" }, ...)
   - server.tool("get_mixer", { description: "Get mixer track information" }, ...)
   - server.tool("get_patterns", { description: "Get all patterns in the project" }, ...)

3. Create src/tools/patterns.ts:
   - Import z from 'zod' for schema validation

   - server.tool("pattern_select", {
       description: "Select a pattern by index",
       inputSchema: { index: z.number().int().min(1).describe("Pattern index (1-based)") }
     }, async ({ index }) => {
       const result = await connection.executeCommand('pattern.select', { index });
       return { content: [{ type: "text", text: JSON.stringify(result) }] };
     });

   - server.tool("pattern_create", {
       description: "Create a new empty pattern"
     }, async () => {
       const result = await connection.executeCommand('pattern.create', {});
       return { content: [{ type: "text", text: JSON.stringify(result) }] };
     });

   - server.tool("pattern_rename", {
       description: "Rename a pattern",
       inputSchema: {
         index: z.number().int().min(1).optional().describe("Pattern index (defaults to current)"),
         name: z.string().describe("New pattern name")
       }
     }, async ({ index, name }) => {
       const result = await connection.executeCommand('pattern.rename', { index, name });
       return { content: [{ type: "text", text: JSON.stringify(result) }] };
     });

4. Create src/tools/index.ts:
   - Import all register functions
   - export function registerTools(server: McpServer, connection: ConnectionManager):
     - registerTransportTools(server, connection)
     - registerStateTools(server, connection)
     - registerPatternTools(server, connection)

5. Update src/index.ts:
   - Import ConnectionManager
   - Import registerTools from tools/index
   - Create ConnectionManager instance
   - Before server.connect():
     - Try to connect to MIDI ports (use env vars or defaults: FL_MIDI_IN, FL_MIDI_OUT)
     - If connection fails, log warning but continue (tools will error when used)
   - Call registerTools(server, connection)
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Run `npm run dev` - should list registered tools.
  </verify>
  <done>
All tool files exist and compile.
Tools are registered with the MCP server.
Server attempts MIDI connection on startup.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end communication with FL Studio</name>
  <what-built>
Complete FL Studio MCP integration:
- MCP server with transport, state, and pattern tools
- FL Bridge script with command handlers
- SysEx-based bidirectional communication
  </what-built>
  <how-to-verify>
**Setup (one-time):**
1. Install loopMIDI from https://www.tobias-erichsen.de/software/loopmidi.html
2. Create two virtual MIDI ports in loopMIDI:
   - "FL Bridge In" (MCP server sends to this, FL reads from it)
   - "FL Bridge Out" (FL sends to this, MCP server reads from it)
3. Copy fl-bridge/ folder to FL Studio's MIDI scripts folder:
   - Usually: C:\Users\[username]\Documents\Image-Line\FL Studio\Settings\Hardware\FLBridge\
   - Or: C:\Program Files\Image-Line\FL Studio 2025\System\Hardware\FLBridge\
4. Restart FL Studio
5. In FL Studio: Options > MIDI Settings:
   - Find "FLBridge" in controller list
   - Set Input port to "FL Bridge In"
   - Set Output port to "FL Bridge Out"
   - Enable the controller

**Testing:**
1. Open FL Studio with a simple project (at least one pattern)
2. Start MCP server: `npm run dev`
3. Check server connects to MIDI ports (no connection errors in console)
4. In Claude Code or MCP inspector:
   - Call `transport_state` - should return current playback state
   - Call `transport_play` - FL Studio should start playing
   - Call `transport_stop` - FL Studio should stop
   - Call `get_patterns` - should list patterns from the project
   - Call `pattern_create` - should create a new empty pattern
   - Call `get_channels` - should list channels in channel rack

**Expected results:**
- All tool calls return JSON responses (not errors)
- FL Studio responds to transport commands
- State queries return accurate project information
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues encountered</resume-signal>
</task>

</tasks>

<verification>
- [ ] FL Bridge handlers implemented for transport, state, patterns
- [ ] MCP tools implemented for transport, state, patterns
- [ ] Server attempts MIDI connection on startup
- [ ] `npm run build` compiles without errors
- [ ] End-to-end communication verified with FL Studio (human checkpoint)
</verification>

<success_criteria>
1. User can start MCP server and it connects to FL Studio without errors
2. User can control transport (play/stop/record) via MCP tools
3. User can query current project state (patterns, tracks, mixer channels) and get accurate response
4. User can select and create patterns via MCP tools
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-communication/01-03-SUMMARY.md`
</output>
