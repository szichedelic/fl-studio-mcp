---
phase: 01-foundation-communication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - fl-bridge/device_FLBridge.py
  - fl-bridge/protocol/sysex.py
  - fl-bridge/protocol/commands.py
  - fl-bridge/protocol/__init__.py
autonomous: true

must_haves:
  truths:
    - "FL Bridge script loads in FL Studio without crashing"
    - "Script handles SysEx messages via OnSysEx callback"
    - "Script can queue responses for OnIdle delivery"
    - "All initialization code is wrapped in try/except"
  artifacts:
    - path: "fl-bridge/device_FLBridge.py"
      provides: "FL Studio MIDI Controller Script entry point"
      contains: "def OnSysEx"
    - path: "fl-bridge/protocol/sysex.py"
      provides: "SysEx message parsing and building"
      contains: "def parse_sysex"
    - path: "fl-bridge/protocol/commands.py"
      provides: "Command routing and response building"
      contains: "def execute_command"
  key_links:
    - from: "fl-bridge/device_FLBridge.py"
      to: "fl-bridge/protocol/sysex.py"
      via: "import for message handling"
      pattern: "from protocol.sysex import"
    - from: "fl-bridge/device_FLBridge.py"
      to: "fl-bridge/protocol/commands.py"
      via: "import for command execution"
      pattern: "from protocol.commands import"
---

<objective>
Create the FL Studio MIDI Controller Script (FL Bridge) with safe initialization, SysEx protocol handling, and command routing infrastructure.

Purpose: This is the FL Studio side of the communication bridge. Without this script running inside FL Studio, the MCP server has nothing to talk to.

Output: A Python script that can be loaded by FL Studio, receives SysEx messages, parses them, routes to command handlers, and sends responses. No actual command handlers yet - just the infrastructure.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-communication/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FL Bridge entry point with safe initialization</name>
  <files>fl-bridge/device_FLBridge.py</files>
  <action>
Create fl-bridge/device_FLBridge.py:

CRITICAL: FL Studio crashes silently on initialization errors. ALL module-level code must be wrapped in try/except.

1. Module-level setup (wrapped in try/except):
   - Try to import device, transport, patterns, channels, mixer from FL Studio
   - If import fails (running outside FL Studio), create mock objects for testing
   - Initialize _response_queue = [] for queuing responses
   - Initialize _handlers = {} for command routing (populated by commands.py)

2. Create OnInit():
   - Print "FL Bridge: Initializing..."
   - Try to import protocol modules (lazy import for safety)
   - Print "FL Bridge: Ready" on success
   - Catch ALL exceptions, print error, but don't crash

3. Create OnDeInit():
   - Print "FL Bridge: Shutting down"
   - Clear response queue

4. Create OnSysEx(event):
   - Wrap ENTIRE function in try/except
   - Check if message starts with 0xF0 0x7D (our manufacturer ID)
   - If not our message, return without handling (other scripts may use SysEx)
   - Parse SysEx using protocol.sysex.parse_sysex(event.sysex)
   - Execute command using protocol.commands.execute_command(parsed)
   - Queue response in _response_queue
   - Set event.handled = True
   - On ANY exception: print error, set event.handled = True (prevent FL crash)

5. Create OnIdle():
   - Process at most 1 response per call (prevent blocking)
   - If _response_queue is not empty:
     - Pop first response
     - Build SysEx response using protocol.sysex.build_sysex_response()
     - Send via device.midiOutSysex(bytes(response))
   - Catch exceptions, print error, continue

6. Create OnMidiMsg(event):
   - Placeholder for future non-SysEx MIDI if needed
   - Currently just returns

The file name MUST be device_FLBridge.py (FL Studio naming convention: device_*.py for MIDI Controller Scripts).

Include comprehensive docstrings explaining the safe initialization pattern.
  </action>
  <verify>
Python syntax check: `python -m py_compile fl-bridge/device_FLBridge.py`
The file should have no syntax errors. (Cannot verify FL Studio loading without FL Studio running)
  </verify>
  <done>
device_FLBridge.py exists with all FL Studio callbacks (OnInit, OnDeInit, OnSysEx, OnIdle).
All code is wrapped in try/except to prevent crashes.
Script can be syntax-checked without FL Studio.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SysEx protocol and command routing</name>
  <files>fl-bridge/protocol/__init__.py, fl-bridge/protocol/sysex.py, fl-bridge/protocol/commands.py</files>
  <action>
1. Create fl-bridge/protocol/__init__.py:
   - Empty file to make protocol a package

2. Create fl-bridge/protocol/sysex.py:
   - Define constants:
     - SYSEX_START = 0xF0
     - SYSEX_END = 0xF7
     - MANUFACTURER_ID = 0x7D (non-commercial)
     - ORIGIN_CLIENT = 0x00
     - ORIGIN_SERVER = 0x01
     - MSG_TYPE_COMMAND = 0x01
     - MSG_TYPE_RESPONSE = 0x02
     - STATUS_OK = 0x00
     - STATUS_ERROR = 0x01

   - def parse_sysex(data: bytes) -> dict:
     - Validate starts with F0 7D, ends with F7
     - Extract: origin (byte 2), client_id (byte 3), continuation (byte 4), msg_type (byte 5), status (byte 6)
     - Extract payload (bytes 7 to -1)
     - Base64 decode payload to get JSON string
     - JSON parse to get command object
     - Return { 'client_id': int, 'command': dict }
     - On error, return { 'client_id': 0, 'error': str }

   - def build_sysex_response(client_id: int, response: dict, success: bool = True) -> list:
     - JSON stringify response
     - Base64 encode
     - Build: [F0, 7D, ORIGIN_SERVER, client_id, 0x00, MSG_TYPE_RESPONSE, STATUS_OK/ERROR, ...payload, F7]
     - Return as list of ints

   - Import base64 and json (standard library, safe)

3. Create fl-bridge/protocol/commands.py:
   - Define _handlers: dict = {} (command handlers registry)

   - def register_handler(action: str, handler: callable):
     - Add handler to _handlers dict
     - Used by handler modules to register themselves

   - def execute_command(parsed: dict) -> dict:
     - If 'error' in parsed, return error response
     - Extract action from parsed['command']['action']
     - Extract params from parsed['command'].get('params', {})
     - Look up handler in _handlers
     - If not found, return { 'success': False, 'error': f'Unknown action: {action}' }
     - Call handler(params)
     - Return result
     - Wrap in try/except, return error response on exception

   - def build_response(client_id: int, result: dict) -> dict:
     - Package result with client_id for response building
     - Return { 'client_id': client_id, 'response': result }

Include type hints where possible (FL Studio Python 3.9 supports them).
  </action>
  <verify>
Python syntax check all files:
- `python -m py_compile fl-bridge/protocol/sysex.py`
- `python -m py_compile fl-bridge/protocol/commands.py`

Test sysex.py in isolation (outside FL Studio):
```python
from protocol.sysex import build_sysex_response, parse_sysex
# Build a response
resp = build_sysex_response(1, {'success': True, 'data': 'test'})
print(f"Built response: {len(resp)} bytes")
# Verify it starts/ends correctly
assert resp[0] == 0xF0 and resp[-1] == 0xF7
```
  </verify>
  <done>
Protocol package exists with sysex.py and commands.py.
parse_sysex can decode incoming messages.
build_sysex_response can encode outgoing responses.
execute_command routes to registered handlers.
All files pass syntax checking.
  </done>
</task>

</tasks>

<verification>
- [ ] fl-bridge/device_FLBridge.py exists and passes syntax check
- [ ] fl-bridge/protocol/sysex.py exists and passes syntax check
- [ ] fl-bridge/protocol/commands.py exists and passes syntax check
- [ ] All callbacks present: OnInit, OnDeInit, OnSysEx, OnIdle
- [ ] All module-level code wrapped in try/except
- [ ] SysEx can be built and parsed in round-trip test
</verification>

<success_criteria>
1. FL Bridge script structure follows FL Studio MIDI Controller Script conventions
2. All initialization code is protected against crashes
3. SysEx protocol matches the format defined in RESEARCH.md
4. Command routing infrastructure is in place (no handlers yet)
5. All Python files pass syntax checking
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-communication/01-02-SUMMARY.md`
</output>
