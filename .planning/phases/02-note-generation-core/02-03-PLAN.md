---
phase: 02-note-generation-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/tools/notes.ts
  - src/tools/index.ts
autonomous: false

must_haves:
  truths:
    - "User can call add_notes tool with raw note data and FL Bridge receives the command"
    - "User can call create_chord_progression tool with key and roman numerals and notes are staged in FL Studio"
    - "User can call create_melody tool with key/scale/density and a melody is staged"
    - "User can call create_bass_line tool with key and chord progression and bass notes are staged"
    - "User can call get_scale_info tool to see available notes in a scale"
    - "All tools return helpful text including the trigger hint for the .pyscript"
    - "Tool responses tell the user what was generated and how to apply it"
  artifacts:
    - path: "src/tools/notes.ts"
      provides: "MCP tool registration for note generation tools"
      exports: ["registerNoteTools"]
    - path: "src/tools/index.ts"
      provides: "Updated tool index importing and registering note tools"
      contains: "registerNoteTools"
  key_links:
    - from: "src/tools/notes.ts"
      to: "src/music/chords.ts"
      via: "imports generateChordProgression"
      pattern: "import.*from.*music/chords"
    - from: "src/tools/notes.ts"
      to: "src/music/melody.ts"
      via: "imports generateMelody, generateBassLine"
      pattern: "import.*from.*music/melody"
    - from: "src/tools/notes.ts"
      to: "src/bridge/connection.ts"
      via: "calls connection.executeCommand('pianoroll.addNotes', ...)"
      pattern: "executeCommand.*pianoroll\\.addNotes"
    - from: "src/tools/index.ts"
      to: "src/tools/notes.ts"
      via: "imports and calls registerNoteTools"
      pattern: "import.*registerNoteTools"
---

<objective>
Wire the music theory engine (Plan 01) to the FL Bridge pianoroll handler (Plan 02) via MCP tools that users can invoke through natural language.

Purpose: This is the final connection that makes "create a C major chord progression" actually work end-to-end. The MCP tools accept musical parameters, use the music theory engine to generate NoteData arrays, then send them to the FL Bridge via SysEx where they get staged as JSON for the piano roll script.

Output: Six MCP tools registered in the server: add_notes, create_chord_progression, create_melody, create_bass_line, get_scale_info, clear_notes.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-note-generation-core/02-RESEARCH.md

This plan depends on prior plans:
@.planning/phases/02-note-generation-core/02-01-SUMMARY.md (music theory engine)
@.planning/phases/02-note-generation-core/02-02-SUMMARY.md (FL Bridge pianoroll handler)

Reference existing patterns:
@src/tools/transport.ts (for tool registration pattern - no params)
@src/tools/patterns.ts (for tool registration pattern - with zod schemas)
@src/tools/index.ts (for registerTools pattern)
@src/bridge/connection.ts (for executeCommand API)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP note tools with zod schemas</name>
  <files>
    src/tools/notes.ts
    src/tools/index.ts
  </files>
  <action>
    1. Create `src/tools/notes.ts` following the EXACT pattern from `src/tools/patterns.ts`:
       - Import McpServer, ConnectionManager, z from zod
       - Import music modules: generateChordProgression, generateMelody, generateBassLine from src/music/
       - Import types: NoteData from src/music/types
       - Import getAvailableScales, getScaleInfo from src/music/scales
       - Export `registerNoteTools(server: McpServer, connection: ConnectionManager): void`

    Define schemas OUTSIDE the server.tool calls (matching patterns.ts approach to avoid deep type instantiation):

    a. **add_notes** tool:
       Schema:
       ```typescript
       const addNotesSchema = {
         notes: z.array(z.object({
           midi: z.number().int().min(0).max(127).describe('MIDI note number (60 = middle C)'),
           time: z.number().min(0).describe('Start time in beats (quarter notes)'),
           duration: z.number().min(0.01).describe('Duration in beats'),
           velocity: z.number().min(0).max(1).default(0.78).describe('Note velocity 0-1'),
           pan: z.number().min(0).max(1).default(0.5).optional().describe('Pan 0-1 (0.5=center)'),
           color: z.number().int().min(0).max(15).default(0).optional().describe('Note color 0-15'),
         })).describe('Array of notes to add'),
         channel: z.number().int().min(0).optional().describe('Target channel index (0-based)'),
         clearFirst: z.boolean().default(false).optional().describe('Clear existing notes before adding'),
       };
       ```
       Handler: Send notes directly to FL Bridge via `connection.executeCommand('pianoroll.addNotes', { notes, channel, clearFirst })`.
       Return text describing how many notes were staged and the trigger hint.

    b. **create_chord_progression** tool:
       Schema:
       ```typescript
       const chordProgressionSchema = {
         key: z.string().describe('Musical key, e.g. "C", "A", "F#"'),
         scale: z.string().default('major').describe('Scale type: "major", "minor", "dorian", etc.'),
         progression: z.array(z.string()).describe('Roman numerals: ["I", "V", "vi", "IV"]'),
         octave: z.number().int().min(1).max(8).default(4).describe('Base octave'),
         beatsPerChord: z.number().default(4).describe('Beats per chord'),
         velocity: z.number().min(0).max(1).default(0.78).describe('Note velocity'),
         channel: z.number().int().min(0).optional().describe('Target channel index'),
         clearFirst: z.boolean().default(false).optional().describe('Clear existing notes first'),
       };
       ```
       Handler:
       - Call `generateChordProgression({ key, scale, progression, octave, beatsPerChord, velocity })`
       - Send resulting NoteData[] to FL Bridge via `connection.executeCommand('pianoroll.addNotes', { notes, channel, clearFirst })`
       - Return text describing what was generated: "Generated [N] chords: [chord names]. [total notes] notes staged. Trigger ComposeWithBridge in Piano Roll to apply."

    c. **create_melody** tool:
       Schema:
       ```typescript
       const melodySchema = {
         key: z.string().describe('Musical key'),
         scale: z.string().default('major').describe('Scale type'),
         octave: z.number().int().min(1).max(8).default(4).describe('Base octave'),
         bars: z.number().int().min(1).max(32).default(4).describe('Number of bars'),
         noteDensity: z.enum(['sparse', 'medium', 'dense']).default('medium').describe('Note density'),
         direction: z.enum(['ascending', 'descending', 'mixed']).default('mixed').describe('Melodic direction tendency'),
         velocity: z.number().min(0).max(1).default(0.75).describe('Note velocity'),
         channel: z.number().int().min(0).optional().describe('Target channel index'),
         clearFirst: z.boolean().default(false).optional().describe('Clear existing notes first'),
       };
       ```
       Handler: Call generateMelody, send to FL Bridge, return descriptive text.

    d. **create_bass_line** tool:
       Schema:
       ```typescript
       const bassLineSchema = {
         key: z.string().describe('Musical key'),
         scale: z.string().default('major').describe('Scale type'),
         chordProgression: z.array(z.string()).describe('Roman numerals the bass follows'),
         octave: z.number().int().min(1).max(4).default(2).describe('Bass octave'),
         beatsPerChord: z.number().default(4).describe('Beats per chord'),
         style: z.enum(['whole', 'half', 'walking', 'eighth']).default('whole').describe('Bass rhythm style'),
         velocity: z.number().min(0).max(1).default(0.82).describe('Note velocity'),
         channel: z.number().int().min(0).optional().describe('Target channel index'),
         clearFirst: z.boolean().default(false).optional().describe('Clear existing notes first'),
       };
       ```
       Handler: Call generateBassLine, send to FL Bridge, return descriptive text.

    e. **get_scale_info** tool:
       Schema:
       ```typescript
       const scaleInfoSchema = {
         key: z.string().describe('Root note, e.g. "C", "Ab", "F#"'),
         scale: z.string().default('major').describe('Scale name'),
       };
       ```
       Handler: Call getScaleInfo to get notes/intervals/chroma. Also call getAvailableScales if scale name is "list". Return formatted text with scale notes and info.

    f. **clear_notes** tool:
       Schema: `{ channel: z.number().int().min(0).optional() }`
       Handler: Send `connection.executeCommand('pianoroll.clearNotes', { channel })`. Return trigger hint text.

    For ALL tool handlers:
    - Wrap in try/catch and return error text on failure
    - Format response text to be helpful: include what was generated, note count, and always include the trigger hint "Run ComposeWithBridge from Piano Roll > Tools > Scripting to apply"
    - Use `JSON.stringify(result, null, 2)` for the FL Bridge response, but also add a human-readable summary above it

    2. Update `src/tools/index.ts`:
       - Add import: `import { registerNoteTools } from './notes.js';`
       - Add call in registerTools: `registerNoteTools(server, connection);`
       - Update console.error log to include 'notes' in the list
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - Verify src/tools/notes.ts exports registerNoteTools
    - Verify src/tools/index.ts imports and calls registerNoteTools
    - Verify all six tools have proper zod schemas and handler implementations
  </verify>
  <done>
    - src/tools/notes.ts exists with six registered MCP tools
    - src/tools/index.ts registers note tools alongside existing tools
    - All tools have zod schemas for input validation
    - All tools call the music theory engine and forward results to FL Bridge
    - All tool responses include helpful text and the .pyscript trigger hint
    - npm run build succeeds
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete note generation pipeline: MCP tools -> music theory engine -> FL Bridge -> JSON staging -> Piano Roll Script.

    Six new MCP tools:
    1. `add_notes` - raw MIDI note placement
    2. `create_chord_progression` - chord progressions from roman numerals
    3. `create_melody` - melodies with scale locking
    4. `create_bass_line` - bass lines following chords
    5. `get_scale_info` - scale information lookup
    6. `clear_notes` - clear piano roll notes
  </what-built>
  <how-to-verify>
    **Setup (one-time):**
    1. Copy `piano-roll-scripts/ComposeWithBridge.pyscript` to `Documents/Image-Line/FL Studio/Settings/Piano roll scripts/`
    2. Make sure FL Bridge (fl-bridge folder) is in `Documents/Image-Line/FL Studio/Settings/Hardware/`
    3. Start FL Studio, open a project, create or select a channel with an instrument (e.g., FL Keys)
    4. Verify loopMIDI ports are running, MCP server connects

    **Test 1: Chord Progression**
    1. Use Claude to say: "Create a I-V-vi-IV chord progression in C major"
    2. This should invoke `create_chord_progression` tool
    3. Tool response should mention notes were staged
    4. Open Piano Roll for the target channel
    5. Run ComposeWithBridge: Piano Roll menu > Tools > last item or search "ComposeWithBridge"
    6. Verify: Four chords appear (C major, G major, A minor, F major), each lasting 4 beats

    **Test 2: Melody**
    1. Use Claude to say: "Write a melody in A minor, 4 bars, medium density"
    2. Tool response should describe the melody
    3. Trigger ComposeWithBridge in Piano Roll
    4. Verify: Notes appear, all within A minor scale, spread across 4 bars

    **Test 3: Bass Line**
    1. Use Claude to say: "Add a walking bass line following I-V-vi-IV in C major"
    2. Trigger ComposeWithBridge
    3. Verify: Bass notes appear in low octave, following the chord roots

    **Test 4: Scale Info**
    1. Ask Claude: "What notes are in D dorian?"
    2. Tool should return scale notes and intervals without needing FL Studio

    **Expected behavior:** Each tool stages notes and returns a message telling you to trigger the piano roll script. Notes appear correctly after triggering.
  </how-to-verify>
  <resume-signal>Type "approved" if notes appear correctly in FL Studio piano roll, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- All six MCP tools are registered and appear in the server tool list
- Tools correctly call music theory functions and forward to FL Bridge
- Tool responses are helpful and include trigger instructions
- End-to-end flow works: tool call -> music theory -> SysEx -> FL Bridge -> JSON -> .pyscript -> notes in piano roll
</verification>

<success_criteria>
1. User can create chord progressions from roman numeral notation
2. User can create melodies with scale locking and density control
3. User can create bass lines following chord progressions
4. User can query scale information
5. Notes appear correctly in FL Studio piano roll after triggering ComposeWithBridge
6. All generated notes conform to the specified key/scale
</success_criteria>

<output>
After completion, create `.planning/phases/02-note-generation-core/02-03-SUMMARY.md`
</output>
