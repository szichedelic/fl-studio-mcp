---
phase: 02-note-generation-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/music/types.ts
  - src/music/theory.ts
  - src/music/scales.ts
  - src/music/chords.ts
  - src/music/melody.ts
autonomous: true

must_haves:
  truths:
    - "Scale.get returns correct MIDI note numbers for any key/scale combination"
    - "Chord progression generator produces correct notes for roman numeral input"
    - "Melody generator produces scale-locked notes with musically sensible contour"
    - "Bass line generator produces root-movement notes following a chord progression"
    - "All generated notes use the NoteData interface with midi, time, duration, velocity"
  artifacts:
    - path: "src/music/types.ts"
      provides: "NoteData interface, ChordProgressionParams, MelodyParams, BassLineParams"
      exports: ["NoteData", "ChordProgressionParams", "MelodyParams", "BassLineParams"]
    - path: "src/music/theory.ts"
      provides: "Core music theory helpers: note-to-MIDI, scale notes, roman numeral resolution"
      exports: ["noteToMidi", "getScaleMidiNotes", "romanNumeralToChord", "getChordNotes"]
    - path: "src/music/scales.ts"
      provides: "Scale locking: snap-to-scale, is-in-scale, available scales list"
      exports: ["snapToScale", "isInScale", "getAvailableScales"]
    - path: "src/music/chords.ts"
      provides: "Chord progression generation from roman numerals"
      exports: ["generateChordProgression"]
    - path: "src/music/melody.ts"
      provides: "Melody and bass line generation algorithms"
      exports: ["generateMelody", "generateBassLine"]
  key_links:
    - from: "src/music/chords.ts"
      to: "src/music/theory.ts"
      via: "imports romanNumeralToChord, getChordNotes"
      pattern: "import.*from.*theory"
    - from: "src/music/melody.ts"
      to: "src/music/scales.ts"
      via: "imports snapToScale for scale locking"
      pattern: "import.*from.*scales"
    - from: "src/music/melody.ts"
      to: "src/music/theory.ts"
      via: "imports getScaleMidiNotes for note selection"
      pattern: "import.*from.*theory"
---

<objective>
Build the music theory engine in TypeScript using the `tonal` library.

Purpose: All music theory logic (scales, chords, melodies, bass lines) lives on the MCP server side. This is the "brain" that converts natural language musical intent into concrete MIDI note data. The FL Bridge only receives pre-computed note arrays.

Output: Five TypeScript modules in `src/music/` that can generate NoteData arrays for any chord progression, melody, or bass line request.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-note-generation-core/02-RESEARCH.md

Reference existing patterns:
@src/bridge/types.ts (for type definition patterns)
@src/tools/patterns.ts (for how tools will consume music modules in Plan 03)
@package.json (for adding tonal dependency)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install tonal and create NoteData types + theory helpers</name>
  <files>
    package.json
    src/music/types.ts
    src/music/theory.ts
    src/music/scales.ts
  </files>
  <action>
    1. Install tonal: `npm install tonal`

    2. Create `src/music/types.ts` with these interfaces:
       - `NoteData`: { midi: number (0-127), time: number (beats), duration: number (beats), velocity: number (0-1), pan?: number (0-1, default 0.5), color?: number (0-15) }
       - `ChordProgressionParams`: { key: string, scale?: string (default "major"), progression: string[] (roman numerals like ["I","V","vi","IV"]), octave?: number (default 4), beatsPerChord?: number (default 4), velocity?: number (default 0.78) }
       - `MelodyParams`: { key: string, scale?: string (default "major"), octave?: number (default 4), bars?: number (default 4), noteDensity?: "sparse"|"medium"|"dense" (default "medium"), direction?: "ascending"|"descending"|"mixed" (default "mixed"), velocity?: number (default 0.75) }
       - `BassLineParams`: { key: string, scale?: string (default "major"), chordProgression: string[] (roman numerals), octave?: number (default 2), beatsPerChord?: number (default 4), style?: "whole"|"half"|"walking"|"eighth" (default "whole"), velocity?: number (default 0.82) }
       - `AddNotesRequest`: { notes: NoteData[], channel?: number, clearFirst?: boolean } -- the JSON payload sent to FL Bridge

    3. Create `src/music/theory.ts` using tonal:
       - `noteToMidi(noteName: string): number | null` -- wraps `Note.midi()` from tonal
       - `midiToNoteName(midi: number): string` -- wraps `Note.fromMidi()` from tonal
       - `getScaleMidiNotes(root: string, scaleName: string, octaveRange: [number, number]): number[]` -- returns all MIDI note numbers in the scale across the octave range. Use `Scale.get()` from tonal to get scale note names, then iterate octaves and convert to MIDI.
       - `romanNumeralToChord(key: string, scaleName: string, numeral: string): string` -- maps a roman numeral (I, ii, iii, IV, V, vi, vii) to a chord name in the given key. Use tonal's `Key.majorKey()` or `Key.minorKey()` to get the chords array. Handle upper/lowercase convention: uppercase = major, lowercase = minor. Support "dim" suffix for vii in major keys.
       - `getChordNotes(chordName: string, octave: number): number[]` -- returns MIDI note numbers for a chord. Use `Chord.get()` from tonal, then convert each note name + octave to MIDI. Handle inversions by checking if notes cross octave boundary (if a note is lower than the root, bump it up an octave).

    4. Create `src/music/scales.ts`:
       - `snapToScale(midiNote: number, root: string, scaleName: string): number` -- snaps a MIDI note to the nearest note in the given scale. Build a chromatic set of scale notes, find closest by absolute distance.
       - `isInScale(midiNote: number, root: string, scaleName: string): boolean` -- checks if a MIDI note belongs to the given scale. Use chroma comparison (midiNote % 12 vs scale chroma from tonal).
       - `getAvailableScales(): string[]` -- returns list of scale names tonal supports. Use `Scale.names()` from tonal.
       - `getScaleInfo(root: string, scaleName: string): { notes: string[], intervals: string[], chroma: string }` -- returns human-readable info about a scale.

    IMPORTANT: Use named imports from "tonal" (e.g., `import { Note, Scale, Chord, Key } from "tonal"`). The tonal package is ESM-compatible and works with our NodeNext module resolution.
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - Manually verify in a quick test: create a temporary file that imports theory.ts and calls `getScaleMidiNotes("C", "major", [4, 5])` -- should return 14 MIDI numbers (C4 through B5 in C major). Run with `npx tsx test-file.ts` then delete.
  </verify>
  <done>
    - tonal is in package.json dependencies
    - src/music/types.ts exports NoteData, ChordProgressionParams, MelodyParams, BassLineParams, AddNotesRequest
    - src/music/theory.ts exports noteToMidi, midiToNoteName, getScaleMidiNotes, romanNumeralToChord, getChordNotes
    - src/music/scales.ts exports snapToScale, isInScale, getAvailableScales, getScaleInfo
    - All functions produce correct output (C major scale gives C,D,E,F,G,A,B notes; I-V-vi-IV in C major gives C,G,Am,F chords)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create chord progression, melody, and bass line generators</name>
  <files>
    src/music/chords.ts
    src/music/melody.ts
  </files>
  <action>
    1. Create `src/music/chords.ts`:
       - `generateChordProgression(params: ChordProgressionParams): NoteData[]`
         - For each roman numeral in `params.progression`:
           a. Use `romanNumeralToChord(params.key, params.scale, numeral)` to get chord name
           b. Use `getChordNotes(chordName, params.octave)` to get MIDI numbers
           c. Create a NoteData for each note with:
              - `time` = currentBeat (starts at 0, increments by beatsPerChord)
              - `duration` = beatsPerChord
              - `velocity` = params.velocity with slight per-note variation (+-0.03 random for natural feel)
           d. Advance currentBeat by beatsPerChord
         - Return all NoteData objects

    2. Create `src/music/melody.ts` with two functions:

       a. `generateMelody(params: MelodyParams): NoteData[]`
          - Get scale MIDI notes for the given key/scale/octave range (octave and octave+1)
          - Determine notes per bar based on density: sparse=2-3, medium=4-6, dense=6-8
          - For each bar (params.bars), generate notes:
            - Pick notes from the scale using weighted random selection
            - Apply direction bias: ascending prefers upward intervals, descending prefers downward, mixed alternates
            - Use step-wise motion primarily (move to adjacent scale notes 70% of time) with occasional leaps (30%)
            - Duration: mix of quarter notes (1 beat), eighth notes (0.5 beats), half notes (2 beats) based on density
            - Velocity: slight random variation around params.velocity (+-0.05)
          - Snap all notes to scale using snapToScale as safety net
          - Return NoteData array

       b. `generateBassLine(params: BassLineParams): NoteData[]`
          - For each chord in params.chordProgression:
            a. Resolve the chord root note using romanNumeralToChord
            b. Get the root note MIDI number at params.octave (bass octave, default 2)
            c. Based on style:
               - "whole": one note per chord, duration = beatsPerChord
               - "half": two notes per chord (root, then fifth), duration = beatsPerChord/2 each
               - "walking": one note per beat, walk between chord tones (root, third, fifth, approach note to next root)
               - "eighth": eighth notes alternating root and fifth (or root and octave)
            d. All notes snapped to scale
          - Return NoteData array

       Use `Math.random()` for randomness (no need for seeded random at this stage). Keep the algorithms simple but musically sensible -- this is v1, not a composition AI.

       AVOID: Do not over-engineer the melody algorithm. A simple "weighted random walk through scale notes" with density control is sufficient. Complex algorithms can come in Phase 9.
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - Quick smoke test: create a temp file that generates a I-V-vi-IV chord progression in C major and prints the result. Verify it produces notes for C major, G major, A minor, F major chords. Run with `npx tsx`, then delete.
    - Quick smoke test: generate a melody in A minor, 4 bars, medium density. Verify all MIDI numbers are in A minor scale. Run with `npx tsx`, then delete.
    - Quick smoke test: generate a walking bass line following I-V-vi-IV in C major. Verify root notes are C2, G2, A2, F2.
  </verify>
  <done>
    - src/music/chords.ts exports generateChordProgression that produces correct chord voicings
    - src/music/melody.ts exports generateMelody that produces scale-locked melodies with variable density
    - src/music/melody.ts exports generateBassLine that follows chord roots with style options
    - All generated notes conform to the specified key/scale (no out-of-scale notes)
    - All notes have valid NoteData fields (midi 0-127, time >= 0, duration > 0, velocity 0-1)
  </done>
</task>

</tasks>

<verification>
- `npm run build` succeeds with zero errors
- All five src/music/*.ts files exist and export their documented functions
- Generated chord progressions produce correct chord tones (verified against known music theory)
- Generated melodies stay within the specified scale
- Generated bass lines follow chord roots at the correct octave
- NoteData interface matches the JSON format expected by the FL Bridge pianoroll handler (Plan 02)
</verification>

<success_criteria>
1. Music theory engine is complete and type-safe
2. Can generate NoteData arrays for: chord progressions, melodies, bass lines
3. All output is scale-locked (no accidental out-of-key notes)
4. Functions are pure (no side effects, no FL Studio dependency)
5. Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-note-generation-core/02-01-SUMMARY.md`
</output>
