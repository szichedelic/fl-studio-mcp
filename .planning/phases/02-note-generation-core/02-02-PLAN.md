---
phase: 02-note-generation-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - fl-bridge/handlers/pianoroll.py
  - fl-bridge/shared/.gitkeep
  - piano-roll-scripts/ComposeWithBridge.pyscript
  - fl-bridge/device_FLBridge.py
autonomous: true

must_haves:
  truths:
    - "FL Bridge handler receives pianoroll.addNotes command and writes JSON to shared directory"
    - "FL Bridge handler receives pianoroll.clearNotes command and writes clear action to JSON"
    - "FL Bridge handler receives pianoroll.readState command and returns current piano roll state from JSON"
    - "Piano roll script reads JSON from shared directory and creates notes via flpianoroll.score.addNote()"
    - "Piano roll script exports current state back to JSON after applying notes"
    - "FL Bridge opens piano roll window and selects correct channel before signaling readiness"
  artifacts:
    - path: "fl-bridge/handlers/pianoroll.py"
      provides: "Command handlers for pianoroll.addNotes, pianoroll.clearNotes, pianoroll.readState"
      contains: "register_handler"
    - path: "piano-roll-scripts/ComposeWithBridge.pyscript"
      provides: "Piano roll script that reads note_request.json and creates notes"
      contains: "flp.score.addNote"
    - path: "fl-bridge/shared/.gitkeep"
      provides: "Shared data directory for JSON IPC between FL Bridge and .pyscript"
  key_links:
    - from: "fl-bridge/handlers/pianoroll.py"
      to: "fl-bridge/shared/note_request.json"
      via: "writes JSON file with note data"
      pattern: "json\\.dump.*note_request"
    - from: "piano-roll-scripts/ComposeWithBridge.pyscript"
      to: "fl-bridge/shared/note_request.json"
      via: "reads JSON file with note data"
      pattern: "json\\.load.*note_request"
    - from: "piano-roll-scripts/ComposeWithBridge.pyscript"
      to: "fl-bridge/shared/piano_roll_state.json"
      via: "writes state JSON after applying notes"
      pattern: "json\\.dump.*piano_roll_state"
    - from: "fl-bridge/device_FLBridge.py"
      to: "fl-bridge/handlers/pianoroll.py"
      via: "imports pianoroll handler module in OnInit"
      pattern: "from handlers import.*pianoroll"
---

<objective>
Build the FL Studio side of note creation: the FL Bridge pianoroll handler that writes note data to JSON, and the companion Piano Roll Script (.pyscript) that reads the JSON and creates notes via flpianoroll.score.addNote().

Purpose: This is the "hands" that actually put notes into FL Studio's piano roll. The MCP server generates note data (Plan 01), sends it via SysEx to the FL Bridge, which writes it to a JSON file. The user then triggers the .pyscript from FL Studio's piano roll menu to apply the notes.

Output: FL Bridge pianoroll handler + ComposeWithBridge.pyscript + shared data directory.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-note-generation-core/02-RESEARCH.md

Reference existing patterns:
@fl-bridge/handlers/patterns.py (for handler registration pattern)
@fl-bridge/protocol/commands.py (for register_handler API)
@fl-bridge/device_FLBridge.py (for OnInit handler import pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FL Bridge pianoroll handler and shared data directory</name>
  <files>
    fl-bridge/handlers/pianoroll.py
    fl-bridge/shared/.gitkeep
    fl-bridge/device_FLBridge.py
  </files>
  <action>
    1. Create `fl-bridge/shared/` directory with a `.gitkeep` file (empty). This directory holds the JSON files exchanged between the FL Bridge handler and the .pyscript. Add `fl-bridge/shared/*.json` to `.gitignore` so runtime JSON files are not committed.

    2. Create `fl-bridge/handlers/pianoroll.py` following the EXACT pattern from `fl-bridge/handlers/patterns.py`:

       Imports (with try/except for FL Studio modules):
       ```python
       try:
           import ui
           import channels
       except ImportError:
           ui = None
           channels = None
       ```

       Import `register_handler` from `protocol.commands`.

       Define `SHARED_DIR` as the absolute path to the shared directory:
       ```python
       SHARED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'shared')
       ```

       Implement three handlers:

       a. `handle_pianoroll_add_notes(params)`:
          - Expects `params` with:
            - `notes`: array of {midi, time, duration, velocity, pan?, color?}
            - `channel`: optional int (channel index to target)
            - `clearFirst`: optional bool (if true, include clear action before add)
          - Validates notes array is not empty
          - Creates SHARED_DIR if it doesn't exist (`os.makedirs(SHARED_DIR, exist_ok=True)`)
          - Writes `note_request.json` to SHARED_DIR with structure:
            ```json
            {
              "action": "add_notes",
              "clearFirst": false,
              "notes": [...]
            }
            ```
          - If `channel` is specified and `channels` module available:
            - Call `channels.selectOneChannel(channel)` to target that channel
          - If `ui` module available, call `ui.showWindow(3)` to open piano roll
          - Return:
            ```python
            {
              "success": True,
              "noteCount": len(notes),
              "message": "Notes written to staging file. Trigger ComposeWithBridge script in Piano Roll to apply.",
              "triggerHint": "Piano Roll menu > Tools > Scripting > ComposeWithBridge"
            }
            ```

       b. `handle_pianoroll_clear_notes(params)`:
          - Creates SHARED_DIR if needed
          - Writes `note_request.json` with `{"action": "clear"}`
          - Opens piano roll if ui available
          - Returns `{"success": True, "message": "Clear request staged. Trigger ComposeWithBridge script to apply."}`

       c. `handle_pianoroll_read_state(params)`:
          - Reads `piano_roll_state.json` from SHARED_DIR
          - If file doesn't exist, return `{"success": False, "error": "No piano roll state available. Run ComposeWithBridge script first."}`
          - If file exists, read and return its contents merged with `{"success": True}`

       Register handlers:
       ```python
       register_handler('pianoroll.addNotes', handle_pianoroll_add_notes)
       register_handler('pianoroll.clearNotes', handle_pianoroll_clear_notes)
       register_handler('pianoroll.readState', handle_pianoroll_read_state)
       ```

    3. Update `fl-bridge/device_FLBridge.py` OnInit function to import the pianoroll handler:
       - In the handler import try block (around line 128-131), add `pianoroll` to the import:
         ```python
         from handlers import transport, state, patterns, pianoroll
         ```
       - Update the print statement to include pianoroll:
         ```python
         print("FL Bridge: Handlers registered (transport, state, patterns, pianoroll)")
         ```
  </action>
  <verify>
    - `python -c "import ast; ast.parse(open('fl-bridge/handlers/pianoroll.py').read())"` -- syntax check passes
    - `python -c "import ast; ast.parse(open('fl-bridge/device_FLBridge.py').read())"` -- syntax check passes
    - `fl-bridge/shared/.gitkeep` exists
    - Verify .gitignore has `fl-bridge/shared/*.json` entry
  </verify>
  <done>
    - fl-bridge/handlers/pianoroll.py exists with three registered handlers
    - fl-bridge/shared/ directory exists for JSON IPC
    - device_FLBridge.py imports pianoroll handler in OnInit
    - All Python files pass syntax validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ComposeWithBridge.pyscript for FL Studio Piano Roll</name>
  <files>
    piano-roll-scripts/ComposeWithBridge.pyscript
  </files>
  <action>
    Create `piano-roll-scripts/ComposeWithBridge.pyscript` -- this is a FL Studio Piano Roll Script that reads note data from a JSON file and creates notes in the piano roll.

    IMPORTANT: This file uses the `flpianoroll` module which is ONLY available inside FL Studio's Piano Roll Script environment. It CANNOT be tested outside FL Studio. Write it carefully following the research examples.

    Structure:
    ```python
    """
    ComposeWithBridge - FL Studio Piano Roll Script

    Reads note data written by the FL Bridge MCP handler and creates
    notes in the currently open piano roll.

    INSTALLATION:
    Copy this file to:
      Documents/Image-Line/FL Studio/Settings/Piano roll scripts/

    USAGE:
    1. MCP server sends notes -> FL Bridge writes note_request.json
    2. Open Piano Roll for the target channel
    3. Run this script: Tools menu > Scripting > ComposeWithBridge
    """
    import flpianoroll as flp
    import json
    import os
    ```

    Define `DATA_DIR` pointing to the fl-bridge/shared directory. Use TWO path strategies with fallback:
    - Primary: `os.path.join(os.path.expanduser("~"), "Documents", "Image-Line", "FL Studio", "Settings", "Hardware", "fl-bridge", "shared")`
    - Fallback: Check for the path relative to the script's own location (since .pyscript files may be in a different directory)

    Implement `createForm()` function (optional, returns empty form since we don't need UI controls):
    ```python
    def createForm():
        form = flp.ScriptDialog("ComposeWithBridge", "Apply notes from MCP server")
        return form
    ```

    Implement `apply(form)` function (main entry point called when script runs):
    1. Build request path: `os.path.join(DATA_DIR, "note_request.json")`
    2. If file doesn't exist, show message "No pending note request found." and return
    3. Read and parse JSON
    4. Get PPQ: `ppq = flp.score.PPQ`
    5. Handle "clear" action:
       - Call `flp.score.clearNotes(all=True)` -- NOTE: the `all` parameter may not exist. If it fails, use `flp.score.clear()` or iterate and delete. Check research notes. Actually per the FL Studio API, use `flp.score.clearNotes()` with boolean parameter for "selectOnly" (False = clear all). If API doesn't support parameter, clear by deleting all notes in reverse order.
    6. Handle "add_notes" action:
       - If `clearFirst` is true in the request, clear existing notes first
       - For each note in `request["notes"]`:
         ```python
         note = flp.Note()
         note.number = note_data["midi"]
         note.time = int(note_data["time"] * ppq)
         note.length = int(note_data["duration"] * ppq)
         note.velocity = note_data.get("velocity", 0.78)
         note.pan = note_data.get("pan", 0.5)
         note.color = note_data.get("color", 0)
         flp.score.addNote(note)
         ```
    7. Delete the request file after processing: `os.remove(request_path)`
    8. Call `export_state()` to write current piano roll state

    Implement `export_state()` helper:
    - Read all notes from current piano roll
    - Build state dict with ppq, noteCount, time signature, and notes array
    - Write to `piano_roll_state.json` in DATA_DIR
    - Each note: {midi, time (in beats), duration (in beats), velocity, pan, selected}

    CRITICAL NOTES:
    - `flp.score.addNote(note)` -- this is the ONLY way to add notes
    - `flp.score.PPQ` -- ticks per quarter note, read at runtime
    - `note.velocity` is float 0.0-1.0 (NOT 0-127)
    - `note.time` and `note.length` are in TICKS (multiply beats * PPQ)
    - Do NOT import any non-standard libraries. Only `flpianoroll`, `json`, `os` are available.
    - The script runs in FL Studio's embedded Python, NOT the system Python.
  </action>
  <verify>
    - `python -c "import ast; ast.parse(open('piano-roll-scripts/ComposeWithBridge.pyscript').read())"` -- Python syntax check passes (the .pyscript is valid Python)
    - File exists at `piano-roll-scripts/ComposeWithBridge.pyscript`
    - File contains `import flpianoroll as flp`
    - File contains `flp.score.addNote(note)` call
    - File contains `def apply(form):` entry point
    - Note: Cannot fully test outside FL Studio since flpianoroll is FL Studio-only
  </verify>
  <done>
    - ComposeWithBridge.pyscript exists and is valid Python syntax
    - Script reads note_request.json from the shared directory
    - Script creates notes via flpianoroll.score.addNote() with correct tick conversion
    - Script exports piano roll state to piano_roll_state.json after applying
    - Script handles both "add_notes" and "clear" actions
    - Script cleans up the request file after processing
  </done>
</task>

</tasks>

<verification>
- All Python files pass syntax validation
- FL Bridge pianoroll handler follows the same registration pattern as existing handlers
- ComposeWithBridge.pyscript has the correct entry points (createForm, apply)
- Shared directory exists with .gitkeep
- device_FLBridge.py imports pianoroll handler
- JSON data format matches between handler (writer) and .pyscript (reader)
</verification>

<success_criteria>
1. FL Bridge can receive pianoroll.addNotes commands and stage note data as JSON
2. FL Bridge can receive pianoroll.clearNotes and pianoroll.readState commands
3. ComposeWithBridge.pyscript can read the staged JSON and create notes in piano roll
4. State export allows MCP to read what's in the piano roll
5. All files are syntactically valid Python
</success_criteria>

<output>
After completion, create `.planning/phases/02-note-generation-core/02-02-SUMMARY.md`
</output>
