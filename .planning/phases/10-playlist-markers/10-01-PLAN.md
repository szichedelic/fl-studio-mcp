---
phase: 10-playlist-markers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fl-bridge/handlers/playlist.py
  - fl-bridge/handlers/__init__.py
  - src/tools/playlist.ts
  - src/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "User can query playlist track count and all track names"
    - "User can mute/unmute playlist tracks by index"
    - "User can solo/unsolo playlist tracks by index"
    - "User can rename playlist tracks"
    - "User can set playlist track colors"
  artifacts:
    - path: "fl-bridge/handlers/playlist.py"
      provides: "Playlist track handlers (get_tracks, mute, solo, set_name, set_color)"
      contains: "register_handler('playlist."
    - path: "src/tools/playlist.ts"
      provides: "MCP tools for playlist tracks"
      exports: ["registerPlaylistTools"]
  key_links:
    - from: "src/tools/playlist.ts"
      to: "fl-bridge/handlers/playlist.py"
      via: "connection.executeCommand('playlist.*')"
      pattern: "executeCommand\\('playlist\\."
    - from: "fl-bridge/handlers/__init__.py"
      to: "fl-bridge/handlers/playlist.py"
      via: "import statement"
      pattern: "from handlers import playlist"
---

<objective>
Create playlist track management handlers and MCP tools for querying, muting, soloing, renaming, and coloring playlist tracks.

Purpose: Enable users to organize and control playlist tracks for arrangement (requirements PLAY-01 through PLAY-04).
Output: New playlist.py handler file, new playlist.ts tools file, updated imports.
</objective>

<execution_context>
@C:\Users\jared\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jared\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-playlist-markers/10-RESEARCH.md

# Pattern reference - follow mixer.py structure exactly
@fl-bridge/handlers/mixer.py
@src/tools/mixer.ts
@fl-bridge/handlers/__init__.py
@src/tools/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create playlist.py handler file with track management handlers</name>
  <files>fl-bridge/handlers/playlist.py, fl-bridge/handlers/__init__.py</files>
  <action>
Create `fl-bridge/handlers/playlist.py` following the exact pattern of `mixer.py`:

1. Module docstring documenting all handlers, notes about 1-indexing
2. Import FL Studio modules (playlist, arrangement, transport, general, midi) with try/except for running outside FL
3. Import `register_handler` from protocol.commands

4. Helper function `_validate_playlist_track(index: int) -> str | None`:
   - CRITICAL: Playlist tracks are 1-indexed (first track = 1, not 0)
   - Get track_count from `playlist.trackCount()`
   - Return error message if `index < 1 or index > track_count`
   - Return None if valid

5. Handler `handle_playlist_get_tracks(params)`:
   - Get track_count from `playlist.trackCount()`
   - Iterate from 1 to track_count (1-indexed!)
   - For each track, get: index, name (`getTrackName`), color (`getTrackColor`), muted (`isTrackMuted`), solo (`isTrackSolo`)
   - Return `{success: True, trackCount, tracks: [...]}`

6. Handler `handle_playlist_mute(params)`:
   - Required params: `index` (int), `mute` (bool)
   - Validate track index (1-indexed)
   - CRITICAL: Use `playlist.muteTrack(index, 1 if mute else 0)` - explicit 1/0, NOT -1 toggle
   - Readback with `isTrackMuted(index)`
   - Return `{success: True, index, muted}`

7. Handler `handle_playlist_solo(params)`:
   - Required params: `index` (int), `solo` (bool)
   - Validate track index (1-indexed)
   - CRITICAL: Use `playlist.soloTrack(index, 1 if solo else 0, False)` - explicit 1/0, NOT -1 toggle
   - Third param `False` = don't affect grouped tracks
   - Readback with `isTrackSolo(index)`
   - Return `{success: True, index, soloed}`

8. Handler `handle_playlist_set_name(params)`:
   - Required params: `index` (int), `name` (str)
   - Validate track index
   - Call `playlist.setTrackName(index, name)` - empty string resets to default
   - Readback with `getTrackName(index)`
   - Return `{success: True, index, name}`

9. Handler `handle_playlist_set_color(params)`:
   - Required params: `index` (int), `color` (int) - BGR format from MCP tool
   - Validate track index
   - Call `playlist.setTrackColor(index, color)`
   - Readback with `getTrackColor(index)`
   - Return `{success: True, index, color}`

10. Register all handlers at bottom:
    ```python
    register_handler('playlist.get_tracks', handle_playlist_get_tracks)
    register_handler('playlist.mute', handle_playlist_mute)
    register_handler('playlist.solo', handle_playlist_solo)
    register_handler('playlist.set_name', handle_playlist_set_name)
    register_handler('playlist.set_color', handle_playlist_set_color)
    ```

11. Update `fl-bridge/handlers/__init__.py`:
    - Add `from handlers import playlist` at the end of imports
  </action>
  <verify>
    - File exists: `fl-bridge/handlers/playlist.py`
    - File contains: `register_handler('playlist.get_tracks'`
    - File contains: `register_handler('playlist.mute'`
    - File contains: `register_handler('playlist.solo'`
    - File contains: `register_handler('playlist.set_name'`
    - File contains: `register_handler('playlist.set_color'`
    - `__init__.py` contains: `from handlers import playlist`
    - File contains: `index < 1 or index > track_count` (1-indexed validation)
    - File contains: `1 if mute else 0` (explicit mute)
    - File contains: `1 if solo else 0` (explicit solo)
  </verify>
  <done>
    Python handlers for playlist track management registered:
    - playlist.get_tracks returns all tracks with name/color/mute/solo state
    - playlist.mute/solo use explicit 1/0 (not toggle)
    - playlist.set_name/set_color update track properties
    - All handlers validate 1-indexed track bounds
  </done>
</task>

<task type="auto">
  <name>Task 2: Create playlist.ts MCP tools for track management</name>
  <files>src/tools/playlist.ts, src/tools/index.ts</files>
  <action>
Create `src/tools/playlist.ts` following the exact pattern of `mixer.ts`:

1. Module comment documenting tools
2. Imports:
   ```typescript
   import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
   import type { ConnectionManager } from '../bridge/connection.js';
   import { z } from 'zod';
   ```

3. Copy `rgbHexToBgr` function from mixer.ts (same BGR conversion)

4. Export function `registerPlaylistTools(server: McpServer, connection: ConnectionManager)`:

5. Tool `get_playlist_tracks`:
   - No parameters
   - Description: "Get all playlist tracks with their names, colors, mute, and solo states. Note: Playlist tracks are 1-indexed (first track = 1)."
   - Execute `playlist.get_tracks` with empty params
   - Return JSON result

6. Tool `mute_playlist_track`:
   - Schema: `track: z.number().int().min(1)` (1-indexed!), `mute: z.boolean()`
   - Description: "Mute or unmute a playlist track. Tracks are 1-indexed (first track = 1)."
   - Execute `playlist.mute` with `{index: track, mute}`

7. Tool `solo_playlist_track`:
   - Schema: `track: z.number().int().min(1)` (1-indexed!), `solo: z.boolean()`
   - Description: "Solo or unsolo a playlist track. Tracks are 1-indexed (first track = 1)."
   - Execute `playlist.solo` with `{index: track, solo}`

8. Tool `set_playlist_track_name`:
   - Schema: `track: z.number().int().min(1)`, `name: z.string()`
   - Description: "Set a playlist track's display name. Empty string resets to default. Tracks are 1-indexed."
   - Execute `playlist.set_name` with `{index: track, name}`

9. Tool `set_playlist_track_color`:
   - Schema: `track: z.number().int().min(1)`, `color: z.string()` (RGB hex like "#FF0000")
   - Description: "Set a playlist track's color (accepts RGB hex like '#FF0000'). Tracks are 1-indexed."
   - Convert color to BGR using `rgbHexToBgr(color)`
   - Execute `playlist.set_color` with `{index: track, color: bgrValue}`

10. Update `src/tools/index.ts`:
    - Add import: `import { registerPlaylistTools } from './playlist.js';`
    - Add call: `registerPlaylistTools(server, connection);`
    - Update console.error to include 'playlist' in the list

All tools follow the exact error handling pattern from mixer.ts (try/catch, JSON.stringify result, isError flag).
  </action>
  <verify>
    - `npm run build` completes without TypeScript errors
    - File exists: `src/tools/playlist.ts`
    - File contains: `export function registerPlaylistTools`
    - File contains: `get_playlist_tracks`
    - File contains: `mute_playlist_track`
    - File contains: `solo_playlist_track`
    - File contains: `set_playlist_track_name`
    - File contains: `set_playlist_track_color`
    - File contains: `z.number().int().min(1)` (1-indexed validation)
    - File contains: `rgbHexToBgr`
    - `index.ts` contains: `registerPlaylistTools`
  </verify>
  <done>
    MCP tools for playlist track management registered:
    - get_playlist_tracks: query all tracks
    - mute_playlist_track/solo_playlist_track: control track state
    - set_playlist_track_name/set_playlist_track_color: organize tracks
    - All tools document 1-indexed track numbering
    - Color conversion handles RGB hex to BGR
  </done>
</task>

</tasks>

<verification>
1. TypeScript builds: `npm run build` passes
2. Python syntax: `python -m py_compile fl-bridge/handlers/playlist.py` passes
3. Handler registration: grep confirms all 5 playlist handlers registered
4. MCP tools: grep confirms all 5 playlist tools exported
5. Import chain: __init__.py imports playlist, index.ts calls registerPlaylistTools
</verification>

<success_criteria>
- [ ] `playlist.py` exists with 5 handlers for track management
- [ ] `playlist.ts` exists with 5 MCP tools for track management
- [ ] All handlers validate 1-indexed track bounds (index >= 1)
- [ ] Mute/solo use explicit 1/0 values (not -1 toggle)
- [ ] Color conversion from RGB hex to BGR implemented
- [ ] Import chain updated (__init__.py, index.ts)
- [ ] TypeScript builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/10-playlist-markers/10-01-SUMMARY.md`
</output>
