# Pitfalls Research: Mixer, Playlist, and Project Controls (v2.1)

**Domain:** DAW automation -- mixer control, playlist arrangement, project-level settings
**Researched:** 2026-02-25
**Confidence:** MEDIUM-HIGH (FL Studio API verified via official stubs; known v2.0 pitfalls inform integration patterns)

**Context:** This document covers pitfalls specific to ADDING mixer control, playlist/arrangement, and project settings to the existing FL Studio MCP server (v2.0). The existing system handles note generation, humanization, plugin control, Serum 2 integration, rendering, and sample manipulation. The v2.1 features require new FL Bridge handlers and MCP tools but must integrate with existing architecture patterns.

---

## Critical Pitfalls

### Pitfall 1: No API to Place Pattern Clips on Playlist Timeline

**What goes wrong:**
The team plans "add this pattern to the playlist at bar 8" as a feature, but discovers there is NO function in the FL Studio playlist module to add clips programmatically. The `playlist` module provides track management (name, color, mute, solo, selection) but NO clip placement functions.

**Why it happens:**
FL Studio's playlist module API focuses on track properties and selection state, not timeline manipulation. Functions like `addClip`, `placePattern`, `insertClipAt` do not exist. The playlist tracks themselves are 1-indexed and can be queried, but their clip contents cannot be modified programmatically.

**How to avoid:**
1. Accept that automated clip placement is NOT possible via the current API
2. Design the "arrangement" feature around what IS possible:
   - Read playlist track info (names, colors, mute/solo states)
   - Create/configure patterns (already works via existing `patterns` module)
   - Guide the user: "Drag Pattern 3 to track 2 at bar 8"
3. Consider investigating `general.processRECEvent()` for potential workarounds, but do not promise automated clip placement without validation
4. Clearly document this limitation in MCP tool descriptions
5. Focus on playlist TRACK management (rename, color, mute, solo) rather than clip placement

**Warning signs:**
- Cannot find `addClip`, `placePattern`, or timeline functions in API documentation
- Planning features that require "placing patterns on timeline" programmatically
- Discovering this limitation mid-phase after promising the feature

**Phase to address:** Playlist/Arrangement phase (first task: validate API capabilities before designing tools)

**Sources:** [FL Studio Python API - Playlist Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/playlist/tracks/)

---

### Pitfall 2: Mixer Routing Changes Require Explicit UI Update Call

**What goes wrong:**
The code calls `mixer.setRouteTo(srcTrack, destTrack, True)` to create a routing, but FL Studio's mixer UI does not reflect the change. Users see no visual indication, or worse, the routing appears to work but behaves incorrectly.

**Why it happens:**
FL Studio's mixer routing system requires calling `mixer.afterRoutingChanged()` after ALL routing modifications are complete. If you forget this call, or call it after each individual routing change instead of after a batch, the UI may not update correctly or performance may suffer.

**How to avoid:**
1. Always call `mixer.afterRoutingChanged()` after completing ALL routing operations in a handler
2. Alternatively, use `setRouteTo(..., updateUI=True)` for single routing changes
3. For batch routing operations, accumulate all changes then call `afterRoutingChanged()` once at the end
4. Document this requirement clearly in the routing handler
5. Test routing by verifying BOTH the API return value AND the visual UI state in FL Studio

**Warning signs:**
- Routing commands succeed (no error) but mixer UI shows incorrect routing
- Performance issues when making many routing changes
- UI updates only after selecting a different mixer track

**Phase to address:** Mixer Control phase

**Sources:** [FL Studio Python API - Mixer Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/tracks/)

---

### Pitfall 3: No Programmatic Tempo Setting via API

**What goes wrong:**
The team plans "set tempo to 128 BPM" as a feature, but discovers that `mixer.getCurrentTempo()` is READ-ONLY. There is NO `setTempo()` function in the mixer, transport, or general modules.

**Why it happens:**
FL Studio's Python API exposes tempo for reading but not writing. `mixer.getCurrentTempo(asInt=False)` returns the current tempo as a float, but there is no corresponding setter. Tempo changes require GUI interaction or automation clips.

**How to avoid:**
1. Accept that tempo READING is available but tempo SETTING is not
2. Design tempo tools as read-only: "What's the current tempo?" not "Set tempo to X"
3. For tempo changes, guide the user: "Click the tempo display and type 128"
4. Investigate `general.processRECEvent()` for potential tempo automation, but this is speculative
5. Consider exploring `transport.globalTransport()` command IDs, though no tempo command is documented

**Warning signs:**
- Cannot find `setTempo` in any module documentation
- Planning "set tempo" as a feature without verifying API capability
- User requests "change tempo" and tool fails silently

**Phase to address:** Project Controls phase (validate during research)

**Sources:** [FL Studio Python API - Mixer Properties](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/properties/)

---

### Pitfall 4: Pickup Mode Confusion Causes Parameter Value Jumps

**What goes wrong:**
Setting mixer track volume via `mixer.setTrackVolume(track, value)` causes the fader to jump abruptly, creating audible clicks and breaking any existing automation. Users report unexpected volume changes that don't match their requested value.

**Why it happens:**
The pickup mode parameter controls how FL Studio handles the transition from current value to target value. Without proper pickup mode handling:
- `PIM_None` (0): Immediate jump to new value (default)
- `PIM_Jump` (1): Jump after touch pickup
- `PIM_Takeover` (2): Gradual takeover

If you always use `PIM_None` during playback, you get audible discontinuities. If you use pickup modes incorrectly, the value change may not apply when expected.

**How to avoid:**
1. Use `PIM_None` (0) for programmatic absolute changes when FL Studio is stopped
2. Understand the three pickup modes and document them clearly
3. For relative adjustments during playback, consider using `PIM_Takeover` (2) for smoother transitions
4. Test volume/pan changes DURING playback to hear any clicks/pops
5. Provide clear tool documentation about when values take effect
6. Consider defaulting to immediate (`PIM_None`) since MCP commands are typically deliberate absolute changes

**Warning signs:**
- Audible clicks or pops when changing volume/pan during playback
- Volume changes that don't seem to take effect immediately
- Different behavior when stopped vs. playing

**Phase to address:** Mixer Control phase

**Sources:** [FL Studio Python API - Mixer Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/tracks/)

---

### Pitfall 5: Mixer Track Index 0 is Master -- Off-By-One Errors

**What goes wrong:**
Code that uses 1-based track numbering (user says "track 1") operates on the wrong track because FL Studio's mixer uses 0-based indexing where track 0 is the Master track. The user expects "track 1" to be the first insert track, but the code modifies the Master instead.

**Why it happens:**
Different parts of FL Studio use different indexing:
- Mixer tracks: 0-indexed, where 0 = Master, 1+ = Insert tracks
- Playlist tracks: 1-indexed (documented explicitly)
- Patterns: 1-indexed
- Channels: 0-indexed

This inconsistency leads to off-by-one errors, especially when the user speaks in natural language ("first track", "track 1").

**How to avoid:**
1. Use `mixer.getTrackInfo(midi.TN_Master)` to get the master track index dynamically
2. Use `mixer.getTrackInfo(midi.TN_FirstIns)` to get the first insert track index
3. Convert user-facing track numbers to FL Studio indices explicitly:
   ```python
   def userTrackToIndex(userTrack):
       # User says "track 1" meaning first insert, FL uses index 1 for first insert (0=Master)
       return userTrack  # For insert tracks, user 1 = FL index 1
   ```
4. Document index conventions clearly in each handler
5. Always validate track index is in range (0 to `mixer.trackCount() - 1`)
6. Test with Master track (0) and first insert (1) specifically

**Warning signs:**
- "Set track 1 volume" accidentally changes Master volume
- Track operations work for most tracks but fail on track 1 specifically
- Off-by-one errors in loop iteration over tracks

**Phase to address:** Mixer Control phase

**Sources:** [FL Studio Python API - Mixer Properties](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/properties/)

---

### Pitfall 6: Playlist Track Indexing is 1-Based (Unlike Everything Else)

**What goes wrong:**
Code iterates playlist tracks starting from index 0, causing index-out-of-range errors or missing the first track entirely. The existing mixer and channel handlers use 0-based indexing, so copy-paste patterns from those handlers fail.

**Why it happens:**
FL Studio's playlist module explicitly states: "Playlist tracks are 1-indexed." This is different from:
- Mixer tracks: 0-indexed
- Channels: 0-indexed
- Most programming conventions: 0-indexed

**How to avoid:**
1. Always start playlist track iteration from index 1
2. Document the indexing convention in every playlist handler
3. Use `playlist.trackCount()` as the EXCLUSIVE upper bound (loop 1 to count)
4. Create explicit conversion functions:
   ```python
   def userPlaylistTrackToIndex(userTrack):
       return userTrack  # User 1 = FL index 1 (1-based)

   def flPlaylistIndexToUser(flIndex):
       return flIndex  # FL 1 = User 1 (1-based)
   ```
5. Add validation to reject playlist track index 0
6. Test with first and last playlist tracks specifically

**Warning signs:**
- Index out of range errors on playlist operations
- First playlist track not appearing in results
- Inconsistent track numbering between playlist and mixer tools

**Phase to address:** Playlist/Arrangement phase

**Sources:** [FL Studio Python API - Playlist Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/playlist/tracks/)

---

### Pitfall 7: Arrangement Markers are Limited -- No General Marker API

**What goes wrong:**
The team plans comprehensive marker management (add, delete, move, edit markers) but discovers the `arrangement.markers` module only supports:
- `jumpToMarker(delta, select)` -- relative navigation
- `getMarkerName(index)` -- read marker name
- `addAutoTimeMarker(time, name)` -- add automatic time markers only

There is no function to add regular markers, delete markers, or read marker positions.

**Why it happens:**
FL Studio's marker API is designed for navigation and auto-time markers, not full CRUD (Create, Read, Update, Delete) operations. This matches the "don't alter end user's PC" security philosophy -- full marker manipulation could modify project structure.

**How to avoid:**
1. Accept that marker functionality is LIMITED to:
   - Reading marker names by index
   - Jumping to markers by relative position
   - Adding automatic time markers (tempo-based)
2. Do NOT promise general marker creation, deletion, or editing
3. Design marker tools around reading and navigation only
4. For marker creation, guide users: "Press Ctrl+T to add a marker at the current position"
5. Test what `addAutoTimeMarker` actually creates (it may not be a standard text marker)

**Warning signs:**
- Cannot find `deleteMarker`, `moveMarker`, `setMarkerPosition` functions
- Planning marker management as a full feature set
- User expects "add marker at bar 16" but only auto-time markers work

**Phase to address:** Project Controls phase (validate early)

**Sources:** [FL Studio Python API - Arrangement Markers](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/arrangement/markers/)

---

### Pitfall 8: Mixer Effect Slot Plugin Access Different from Channel Rack

**What goes wrong:**
Code that works for channel rack plugins fails when trying to control mixer effect slot plugins. The same `plugins.setParamValue()` call succeeds for a channel rack VST but silently fails or affects the wrong plugin for a mixer effect slot.

**Why it happens:**
The `plugins` module uses different addressing for channel rack vs. mixer:
- **Channel rack (generator):** `index` = channel index, `slotIndex` = -1
- **Mixer effect slot:** `index` = mixer track index, `slotIndex` = 0-9 (mixer slot)

If you forget to pass the correct `slotIndex` for mixer effects, or use channel indices for mixer tracks, the operation targets the wrong plugin.

**How to avoid:**
1. Always clearly distinguish between channel rack and mixer slot operations
2. Use consistent parameter names:
   - `channelIndex` for channel rack operations (slotIndex = -1)
   - `mixerTrack` + `slotIndex` for mixer effect operations
3. Validate `slotIndex` range (0-9 for mixer slots, -1 for channel rack)
4. Use `mixer.isTrackPluginValid(track, slot)` before operating on mixer effects
5. Document the addressing convention in plugin handler code
6. Test both channel rack AND mixer slot plugins explicitly

**Warning signs:**
- Plugin commands work for instruments but fail for effects
- Wrong plugin responds to commands
- `plugins.isValid()` returns False for known mixer effects

**Phase to address:** Mixer Control phase (when adding mixer plugin slot access)

**Sources:** [FL Studio Python API - Mixer Events](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/events/)

---

## Moderate Pitfalls

### Pitfall 9: Large Mixer Track Count Creates Large SysEx Responses

**What goes wrong:**
Requesting mixer state returns 127 tracks worth of data (FL Studio's mixer has 127 slots: 1 master + 125 insert + 1 current). The response exceeds SysEx payload limits, causing silent truncation or timeout.

**Why it happens:**
The existing `state.mixer` handler iterates ALL mixer tracks:
```python
for i in range(count):
    track_info = { 'index': i, 'name': mixer.getTrackName(i), ... }
```
With 127 tracks and 6+ properties each, the JSON response becomes very large.

**How to avoid:**
1. Implement pagination for mixer track listing: `get_mixer_tracks(start=0, count=20)`
2. Add a "changed only" mode that returns only tracks modified since last query
3. Return only named tracks (many insert tracks are unnamed by default)
4. Use the existing chunked SysEx response pattern (already implemented for plugin parameters)
5. Default to returning only "active" tracks (tracks with routing, effects, or names)
6. Test with full 127-track project to verify chunking works

**Warning signs:**
- `get_mixer` command times out or returns truncated JSON
- Works with few mixer tracks but fails with large projects
- Intermittent failures correlating with project complexity

**Phase to address:** Mixer Control phase

**Sources:** Known from v2.0 pitfalls - SysEx payload size limits

---

### Pitfall 10: State Synchronization Drift for Mixer Changes

**What goes wrong:**
User manually changes mixer volume in FL Studio, then asks Claude to "increase the volume by 10%". The MCP server's cached value is stale, so the calculation is based on the old value, producing an unexpected result.

**Why it happens:**
FL Studio has no push notification system. If the user adjusts a mixer fader manually, the MCP server's shadow state (if any) does not update. Unlike plugin parameters where `getParamValue` is broken, `mixer.getTrackVolume()` DOES work reliably, but the MCP server may not be querying it fresh.

**How to avoid:**
1. For mixer operations, ALWAYS read current state immediately before modifications
2. Do NOT cache mixer track volumes/pans -- they change frequently
3. Design relative operations to fetch-then-modify:
   ```typescript
   async function increaseVolume(track, percent) {
     const current = await bridge.execute('mixer.getVolume', { track });
     const newValue = Math.min(1.0, current + (percent / 100));
     await bridge.execute('mixer.setVolume', { track, value: newValue });
   }
   ```
4. For absolute operations ("set volume to 80%"), no state needed
5. Accept that very rapid manual changes may still race with MCP commands

**Warning signs:**
- Relative adjustments produce unexpected values
- "Increase by 10%" doesn't match expected result after manual tweaking
- Volume/pan "jumps" when MCP command runs after manual change

**Phase to address:** Mixer Control phase

**Sources:** Known from v2.0 architecture - state synchronization drift

---

### Pitfall 11: Mute/Solo State Has Three Values, Not Two

**What goes wrong:**
Code treats mute as a boolean (on/off) but doesn't handle the "toggle" case correctly. User says "mute track 3" when it's already muted, and the toggle behavior unmutes it instead.

**Why it happens:**
`mixer.muteTrack(track, value)` accepts:
- `1` = Force mute
- `0` = Force unmute
- `-1` = Toggle

If your handler always passes `-1` (toggle), "mute track 3" will unmute if already muted. If you always pass `1`, you can't implement "toggle mute."

**How to avoid:**
1. Separate tools for explicit vs. toggle operations:
   - `mute_mixer_track(track)` -- always mutes (value=1)
   - `unmute_mixer_track(track)` -- always unmutes (value=0)
   - `toggle_mixer_track_mute(track)` -- toggles (value=-1)
2. Or use a single tool with explicit mode parameter:
   - `set_mixer_track_mute(track, mute=True)` -- force mute
   - `set_mixer_track_mute(track, mute=False)` -- force unmute
3. Read current state before toggle to report what happened
4. Same pattern for `soloTrack` (though solo has more complexity with solo modes)

**Warning signs:**
- "Mute track" sometimes unmutes
- User reports inconsistent mute behavior
- Toggle operations don't match user expectations

**Phase to address:** Mixer Control phase

**Sources:** [FL Studio Python API - Mixer Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/tracks/)

---

### Pitfall 12: Solo Mode Complexity with Groups and Sources

**What goes wrong:**
User solos a track expecting only that track to play, but tracks routed TO that track also play (send sources), or tracks it routes to also play (send destinations). The solo behavior is different from what the user expected.

**Why it happens:**
`mixer.soloTrack(track, value, inGroup, withSourceTracks)` has multiple modes:
- Include source tracks that route to this track
- Include send destinations
- Include both
- Solo only the track itself (strictest)

The default behavior may not match user expectations.

**How to avoid:**
1. Document the four solo modes clearly in MCP tool descriptions
2. Default to the strictest mode (solo only this track) unless user specifies otherwise
3. Provide verbose feedback: "Soloed track 5 (with routing sources also soloed)"
4. Test with complex routing scenarios (submixes, sends)
5. Consider providing mode parameter: `solo_mixer_track(track, mode='strict'|'with_sources'|'with_sends'|'all')`

**Warning signs:**
- Solo doesn't silence expected tracks
- User confused about what's playing when track is soloed
- Different solo behavior with simple vs. complex routing

**Phase to address:** Mixer Control phase

**Sources:** [FL Studio Python API - Mixer Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/tracks/)

---

### Pitfall 13: Time Signature Not Directly Accessible via API

**What goes wrong:**
The team plans "what time signature is this project?" as a feature, but there is no direct `getTimeSignature()` function. Time signature must be inferred from PPQN calculations or marker data.

**Why it happens:**
FL Studio's general module provides `general.getRecPPQ()` (pulses per quarter note, aka timebase), which affects tick calculations but is not the time signature itself. The actual time signature (4/4, 3/4, 6/8, etc.) is set in the project settings and reflected in markers, but there's no simple getter.

**How to avoid:**
1. Accept that time signature is not directly readable via a simple function
2. If needed, investigate the `arrangement` module's time-related functions
3. Consider using marker position math to infer time signature from bar boundaries
4. Document this limitation in project info tools
5. For practical purposes, default to 4/4 if time signature cannot be determined
6. Guide user: "Check the project settings to verify time signature"

**Warning signs:**
- Cannot find `getTimeSignature` in any module
- Planning time-signature-aware features without verifying API
- Inferred time signature is wrong for odd-meter projects

**Phase to address:** Project Controls phase (validate during research)

**Sources:** [FL Studio Python API - General](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/general/)

---

## Minor Pitfalls

### Pitfall 14: Color Format is BGR, Not RGB

**What goes wrong:**
Setting mixer track or playlist track colors produces the wrong color. Red appears as blue, blue as red.

**Why it happens:**
FL Studio uses `0x--BBGGRR` color format, not the typical `0x--RRGGBB` (RGB) format. This is consistent across `mixer.setTrackColor()` and `playlist.setTrackColor()`.

**How to avoid:**
1. Create a utility function to convert RGB to FL Studio BGR:
   ```python
   def rgb_to_fl_color(r, g, b):
       return (b << 16) | (g << 8) | r
   ```
2. Document the color format in tool schemas
3. Accept both formats in MCP tools and convert internally
4. Test with distinct R/G/B values to verify correct ordering

**Warning signs:**
- Colors appear wrong (red/blue swapped)
- User specifies red, track turns blue

**Phase to address:** Mixer Control or Playlist phase (any color-setting features)

**Sources:** [FL Studio Python API - Playlist Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/playlist/tracks/)

---

### Pitfall 15: Volume Values are Non-Linear (0.8 = Unity Gain)

**What goes wrong:**
Setting volume to 0.5 expecting "half volume" results in much quieter than expected. User says "set to 50%" and the track is barely audible.

**Why it happens:**
FL Studio's volume scale is non-linear. The default value (unity gain, 0 dB) is `0.8`, not `1.0`. Values below 0.8 attenuate, values above 0.8 amplify. The relationship is:
- `0.0` = silence
- `0.8` = 0 dB (unity)
- `1.0` = ~+5.6 dB (amplification)

**How to avoid:**
1. Document that FL Studio volume 0.8 = 0 dB in MCP tool descriptions
2. Consider accepting dB values in tools and converting:
   - Use `mixer.getTrackVolume(track, 1)` to get dB value
   - Provide conversion utilities for dB <-> linear
3. When user says "set to 50%", clarify: percentage of what range?
   - 50% of max (1.0) = 0.5 (quieter than unity)
   - 50% of unity (0.8) = 0.4 (much quieter)
4. Default to interpreting percentages relative to unity (0.8)

**Warning signs:**
- "Set volume to 50%" results in very quiet track
- Volume "100%" causes clipping/distortion
- User complaints about volume math not making sense

**Phase to address:** Mixer Control phase

**Sources:** [FL Studio Python API - Mixer Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/tracks/), [GitHub - flstudio-volume-converter](https://github.com/olyrhc/flstudio-volume-converter)

---

## Technical Debt Patterns

| Shortcut | Immediate Benefit | Long-term Cost | When Acceptable |
|----------|-------------------|----------------|-----------------|
| Iterate all 127 mixer tracks | Simple code | Large payloads, timeouts | Only for initial discovery; paginate for production |
| Cache mixer track values | Faster responses | Stale data, wrong relative calculations | Never for frequently-changed values (volume/pan) |
| Toggle instead of explicit mute/unmute | Less code | Unpredictable behavior | Only when user explicitly says "toggle" |
| Assume 4/4 time signature | Avoids complex inference | Wrong for odd-meter projects | Acceptable as fallback with warning |
| RGB color assumption | Familiar format | Wrong colors | Never -- always convert to BGR |
| Linear volume percentage | Intuitive UX | Doesn't match FL Studio behavior | Only with explicit documentation |

## Integration Gotchas

| Integration | Common Mistake | Correct Approach |
|-------------|----------------|------------------|
| Mixer routing | Forgetting `afterRoutingChanged()` | Call after ALL routing changes complete |
| Mixer plugin slots | Using channel index instead of mixer track | Use `mixerTrack` + `slotIndex` (0-9) |
| Playlist track iteration | Starting from index 0 | Playlist tracks are 1-indexed, start from 1 |
| Track volume | Setting value without understanding 0.8=unity | Document scale, consider dB conversion |
| Tempo reading | Expecting `setTempo()` to exist | `getCurrentTempo()` is read-only |
| Color setting | Using RGB format | FL Studio uses BGR (0x--BBGGRR) |
| Clip placement | Expecting `addClip()` API | No clip placement API exists |
| Markers | Expecting full CRUD | Only navigation and auto-time markers |

## Performance Traps

| Trap | Symptoms | Prevention | When It Breaks |
|------|----------|------------|----------------|
| Full mixer track iteration | Multi-second delays, SysEx timeout | Paginate or filter to named/active tracks | Projects with many mixer tracks used |
| Redundant state queries | Slow response times | Cache immutable properties only (names, colors) | High-frequency operations |
| Routing changes without batch update | UI lag, visual glitches | Batch all routing then call `afterRoutingChanged()` | Complex routing operations |

## "Looks Done But Isn't" Checklist

- [ ] **Mixer routing:** Basic routing works -- verify `afterRoutingChanged()` is called and UI updates correctly
- [ ] **Mixer volume:** Percentage values work -- verify 0 dB is 0.8, not 1.0
- [ ] **Mute/Solo:** Toggle works -- verify explicit mute (value=1) and unmute (value=0) also work
- [ ] **Solo modes:** Basic solo works -- verify behavior with complex routing (submixes, sends)
- [ ] **Playlist tracks:** Track 1 works -- verify index 1 is first track (1-based), not index 0
- [ ] **Markers:** Read works -- verify add/delete is actually NOT supported (don't claim it is)
- [ ] **Tempo:** Read works -- verify set is NOT supported (don't claim it is)
- [ ] **Mixer effects:** Channel rack plugins work -- verify mixer slot plugins (slotIndex 0-9) also work
- [ ] **Colors:** Colors set correctly -- verify red is red (BGR format, not RGB)
- [ ] **Large projects:** Works with 10 mixer tracks -- verify with 100+ mixer tracks (chunking)

## Recovery Strategies

| Pitfall | Recovery Cost | Recovery Steps |
|---------|---------------|----------------|
| No clip placement API discovered late | HIGH | Redesign as guided workflow; cannot automate |
| Routing without `afterRoutingChanged()` | LOW | Add the call; existing routes may need manual refresh |
| Off-by-one indexing errors | LOW | Fix index math; test edge cases |
| Volume scale misunderstanding | LOW | Update documentation; add conversion utilities |
| BGR color confusion | LOW | Add conversion utility; fix existing color code |
| Tempo setting promised but unavailable | MEDIUM | Redesign as read-only; update tool descriptions |
| Large SysEx timeouts | MEDIUM | Implement pagination; already have chunking pattern |

## Pitfall-to-Phase Mapping

| Pitfall | Prevention Phase | Verification |
|---------|------------------|--------------|
| No clip placement API (#1) | Playlist phase (validate first) | Confirm API limitations before designing tools |
| Routing UI update (#2) | Mixer phase | `afterRoutingChanged()` called; UI reflects routing |
| No tempo setting (#3) | Project phase (validate first) | Document as read-only |
| Pickup mode confusion (#4) | Mixer phase | Volume changes don't cause clicks during playback |
| Mixer index 0=Master (#5) | Mixer phase | "Track 1" modifies first insert, not master |
| Playlist 1-indexed (#6) | Playlist phase | First track is index 1, not 0 |
| Limited marker API (#7) | Project phase (validate first) | Only document supported operations |
| Mixer effect slot addressing (#8) | Mixer phase | Mixer slot plugins respond to commands |
| Large mixer response (#9) | Mixer phase | 127-track project doesn't timeout |
| State sync drift (#10) | Mixer phase | Fresh query before relative operations |
| Mute/Solo toggle (#11) | Mixer phase | Explicit mute (1) and unmute (0) both work |
| Solo mode complexity (#12) | Mixer phase | Solo behavior documented and tested |
| Time signature (#13) | Project phase | Document as not directly readable |
| BGR color (#14) | Mixer/Playlist phase | Red color appears red |
| Volume scale (#15) | Mixer phase | Volume 0.8 = 0 dB documented |

## Sources

### HIGH Confidence (Official Documentation)
- [FL Studio Python API - Mixer Module](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/) -- Mixer control functions
- [FL Studio Python API - Mixer Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/tracks/) -- Volume, pan, mute, solo, routing
- [FL Studio Python API - Mixer Properties](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/properties/) -- getCurrentTempo (read-only), trackCount
- [FL Studio Python API - Mixer Events](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/mixer/events/) -- Plugin slot functions
- [FL Studio Python API - Playlist Tracks](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/playlist/tracks/) -- Track management (no clip placement)
- [FL Studio Python API - Arrangement Markers](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/arrangement/markers/) -- Limited marker API
- [FL Studio Python API - Transport](https://il-group.github.io/FL-Studio-API-Stubs/midi_controller_scripting/transport/) -- No tempo setting

### MEDIUM Confidence (Community + Verified)
- [GitHub - flstudio-volume-converter](https://github.com/olyrhc/flstudio-volume-converter) -- Volume dB conversion reference
- v2.0 project ARCHITECTURE.md -- Existing bridge patterns
- v2.0 project PITFALLS.md -- Known issues with plugin control, SysEx size

### LOW Confidence (Needs Hands-On Validation)
- Time signature inference from arrangement data
- `processRECEvent` for tempo/clip automation
- Exact solo mode behavior with complex routing

---
*Pitfalls research for: FL Studio MCP Server v2.1 Song Building & Mixing*
*Researched: 2026-02-25*
