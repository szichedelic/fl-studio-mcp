/**
 * Piano Roll Script Writer
 *
 * Writes the ComposeWithBridge.pyscript with embedded note data.
 * FL Studio's piano roll Python subinterpreter cannot read files,
 * so note data must be embedded as Python literals in the script source.
 *
 * This runs in Node.js (full file system access) to bypass FL Studio's
 * Python restrictions.
 */

import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
import type { NoteData } from './types.js';

// FL Studio Piano Roll Scripts directory
const FL_SETTINGS = join(
  homedir(),
  'Documents',
  'Image-Line',
  'FL Studio',
  'Settings'
);
const PYSCRIPT_DIR = join(FL_SETTINGS, 'Piano roll scripts');
const PYSCRIPT_PATH = join(PYSCRIPT_DIR, 'ComposeWithBridge.pyscript');

/**
 * Python template for the .pyscript file.
 * Placeholders: {action}, {notes}, {clear_first}
 */
const PYSCRIPT_TEMPLATE = `"""
ComposeWithBridge - FL Studio Piano Roll Script
Auto-generated by FL Studio MCP with embedded note data.
"""

import flpianoroll as flp

PENDING_ACTION = {action}
PENDING_NOTES = {notes}
PENDING_CLEAR_FIRST = {clear_first}


def createDialog():
    count = len(PENDING_NOTES)
    action = PENDING_ACTION or "none"
    form = flp.ScriptDialog(
        "ComposeWithBridge",
        "Action: " + action + "\\r\\n"
        "Notes: " + str(count)
    )
    return form


def apply(form):
    if PENDING_ACTION is None:
        flp.Utils.ShowMessage(
            "No pending note request.\\n\\n"
            "Use the MCP server to send notes first."
        )
        return

    ppq = flp.score.PPQ

    if PENDING_ACTION == "clear":
        _clear_all_notes()

    elif PENDING_ACTION == "add_notes":
        if PENDING_CLEAR_FIRST:
            _clear_all_notes()

        for nd in PENDING_NOTES:
            note = flp.Note()
            note.number = nd[0]
            note.time = int(nd[1] * ppq)
            note.length = int(nd[2] * ppq)
            note.velocity = nd[3]
            note.pan = nd[4]
            note.color = nd[5]
            flp.score.addNote(note)


def _clear_all_notes():
    try:
        flp.score.clearNotes(False)
    except (AttributeError, TypeError):
        for i in range(flp.score.noteCount - 1, -1, -1):
            flp.score.deleteNote(i)
`;

/**
 * Convert NoteData to Python tuple representation.
 * Tuple format: (midi, time, duration, velocity, pan, color)
 */
function noteToPythonTuple(note: NoteData): string {
  const midi = Math.round(note.midi);
  const time = note.time;
  const duration = note.duration;
  const velocity = note.velocity ?? 0.78;
  const pan = note.pan ?? 0.5;
  const color = note.color ?? 0;
  return `(${midi}, ${time}, ${duration}, ${velocity}, ${pan}, ${color})`;
}

/**
 * Write the .pyscript with embedded note data.
 *
 * @param action - "add_notes" or "clear"
 * @param notes - Array of NoteData to embed
 * @param clearFirst - Whether to clear existing notes before adding
 * @returns Path to the written .pyscript file
 */
export function writePyscript(
  action: 'add_notes' | 'clear',
  notes: NoteData[] = [],
  clearFirst = false
): string {
  // Ensure directory exists
  if (!existsSync(PYSCRIPT_DIR)) {
    mkdirSync(PYSCRIPT_DIR, { recursive: true });
  }

  // Build Python representation of notes
  let notesPython: string;
  if (notes.length === 0) {
    notesPython = '[]';
  } else {
    const tuples = notes.map(noteToPythonTuple);
    notesPython = '[\n' + tuples.map((t) => `    ${t},`).join('\n') + '\n]';
  }

  // Fill template
  const content = PYSCRIPT_TEMPLATE
    .replace('{action}', JSON.stringify(action))
    .replace('{notes}', notesPython)
    .replace('{clear_first}', clearFirst ? 'True' : 'False');

  writeFileSync(PYSCRIPT_PATH, content, 'utf-8');

  return PYSCRIPT_PATH;
}

export { PYSCRIPT_PATH };
